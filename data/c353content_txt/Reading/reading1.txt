b'\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMicrosoft PowerPoint - Tut1.pptx\n\n\nCOMP 353 - Databases\n\n\n\nThis slides are prepared by:\n\n\xef\xbf\xbdNicole Parmentier\n\n\xef\xbf\xbdnicole.parmentier@mail.concordia.ca\n\n\n\nToday\n\n\xef\xbf\xbdFundamental theory concepts\n\n\xef\xbf\xbdPractice setting up relations\n\n\xef\xbf\xbdPractice reading/writing SQL queries\n\n\n\nWhat is a database?\n\n\xef\xbf\xbdCollection of data stored long-term, \n\norganized in a way that is meaningful \n\nand logical\n\n\xef\xbf\xbde.g. contact list, employee files, etc.\n\n\n\nWhat is a database?\n\n\xef\xbf\xbdDB: Database\n\n\xef\xbf\xbdDBS: Database System\n\n\xef\xbf\xbdDMBS: Database Management System\n\nDBS = DB + DBMS\n\nsystem = data + management\n\n\n\nDMBS\n\n\xef\xbf\xbdOffers convenient and secure access\n\n\xef\xbf\xbdTransaction Management:\n\n\xef\xbf\xbdAtomicity (all or nothing)\n\n\xef\xbf\xbdConsistency (follows rules)\n\n\xef\xbf\xbdIsolation (transactions do not affect each other)\n\n\xef\xbf\xbdDurability (data survives failures)\n\n\n\nDMBS\n\n\xef\xbf\xbdBetter than a simple file directory: \n\nMinimize data \nredundancy to avoid \n\ninconsistency\n\n\n\nRelational Data Model\n\n\xef\xbf\xbdA data model describes data and the \n\nrelationships among that data\n\n\xef\xbf\xbdRelational model organizes data (attributes) into \n\nnamed tables (relations)\n\n\xef\xbf\xbd e.g. \n\nHero = (name, gameTitle, class, level, hitPoints)\n\nGame = (title, platform, releaseYear, genre)\n\n\n\nDefine a relation\n\n\xef\xbf\xbdBook = (title, publisher, releaseDate,\n\nsubject, price, pageCount, inPublicDomain)\n\n\xef\xbf\xbdRelationName = (string, string, date, \n\nstring, float, integer, boolean)\n\n\xef\xbf\xbdMany different relations can be defined \n\naccording to the application requirements\n\n\xef\xbf\xbdDefine a relation for a book:\n\n\n\nLevels of Data\n\n\xef\xbf\xbdView (external): how data is seen by users\n\n\xef\xbf\xbdConceptual (logical) Schema: defined \nrelations, an outcome of database design \n\n\xef\xbf\xbdPhysical (internal) Schema: storage and \nindex structures associated with relations\n\nNote: The levels are independent of the \nones below them\n\n\n\nStructured Query Language (SQL)\n\n\xef\xbf\xbdData Definition Language (DDL)\n\n\xef\xbf\xbdSyntax for declaring tables, indexes, \n\nviews, constraints, etc.\n\n\xef\xbf\xbdData Manipulation Language (DML)\n\n\xef\xbf\xbdQueries \n\n\xef\xbf\xbdTransactions (data modification)\n\n\xef\xbf\xbdSchema creation/modification \n\n\n\nSQL Queries\n\n\xef\xbf\xbdAn SQL query follows the form:\n\nSELECT . . . -select which attributes are output\n\nFROM . . . -which relations to draw data from\n\nWHERE . . . ; -where that data meets these \nconditions (boolean)\n\n\n\nSQL Queries\n\n\xef\xbf\xbdRelation schema:\n\nGame = (title, platform, releaseYear, genre)\n\n\xef\xbf\xbdQuery: Find the titles of all games for the \nplatform \xe2\x80\x98N64\xe2\x80\x99 which are stored in the database\n\n\xef\xbf\xbdQuery in SQL:\n\nSELECT title\n\nFROM Game\n\nWHERE platform = \xe2\x80\x98N64\xe2\x80\x99;\n\n\n\nSQL Queries\n\n\xef\xbf\xbdWHERE clause is a boolean, can be as complex \nas you saw in COMP 232:\n\n\xef\xbf\xbdBook = (title, publisher, releaseDate,\nsubject, price, pageCount, inPublicDomain)\n\nSELECT *\n\nFROM Book\n\nWHERE (price < 19.99 AND (pageCount < 42 OR \npageCount >= 420)) OR title = \xe2\x80\x98Brave New World\xe2\x80\x99;\n\n\xef\xbf\xbdWhat is this query?\n\n\n\nSQL Queries\n\n\xef\xbf\xbdFROM clause can use multiple tables (relations), \n\ncoupled through a Cartesian product\n\nHero = (name, gameTitle, class, level, hitPoints)\n\nGame = (title, platform, releaseYear, genre)\n\nSELECT Hero.name, Game.title , Game.genre\n\nFROM Game, Hero\n\nWHERE Hero.gameTitle = Game.title\n\nAND Game.releaseYear > 1980;\n\n\n\nSQL Queries\n\xef\xbf\xbdRelation schemas:\n\nHero = (name, gameTitle, class, level, hitPoints)\n\nGame = (title, platform, releaseYear, genre)\n\n\xef\xbf\xbd Instances of the relations:\nname gameTitle class level hitPoints\n\nMario Super Mario 64 Plumber 0 1\n\nLink Legend of Zelda Warrior 1 3\n\ntitle platform releaseYear genre\n\nSuper Mario 64 N64 1996 Platformer\n\nPikmin Gamecube 2001 Puzzle-strategy\n\n\n\nCartesian Product\nname gameTitle class level hitPoints\n\nMario Super Mario 64 Plumber 0 1\n\nLink Legend of Zelda Warrior 1 3\n\ntitle platform releaseYear genre\n\nSuper Mario 64 N64 1996 Platformer\n\nPikmin Gamecube 2001 Puzzle\n\nHero x Game\nname gameTitle class level hitPoints title platform releaseYea\n\nr\ngenre\n\nMario Super Mario 64 Plumber 0 1 Super Mario 64 N64 1996 Platformer\n\nMario Super Mario 64 Plumber 0 1 Pikmin Gamecube 2001 Puzzle\n\nLink Legend of Zelda Warrior 1 3 Super Mario 64 N64 1996 Platformer\n\nLink Legend of Zelda Warrior 1 3 Pikmin Gamecube 2001 Puzzle\n\n\n\nSELECT Hero.name, Game.title , Game.genre\n\nFROM Game, Hero\n\nWHERE Hero.gameTitle = Game.title\n\nAND Game.releaseYear > 1980;\n\nname gameTitle class level hitPoints title platform releaseYea\nr\n\ngenre\n\nMario Super Mario 64 Plumber 0 1 Super Mario 64 N64 1996 Platformer\n\nMario Super Mario 64 Plumber 0 1 Pikmin Gamecube 2001 Puzzle\n\nLink Legend of Zelda Warrior 1 3 Super Mario 64 N64 1996 Platformer\n\nLink Legend of Zelda Warrior 1 3 Pikmin Gamecube 2001 Puzzle\n\nname title genre\n\nMario Super Mario 64 Platformer\n\xef\xbf\xbdQuery Result:\n\n\n\nAggregation in SQL\n\xef\xbf\xbdOperations done in the SELECT clause to \n\nsummarize the data\n\n\xef\xbf\xbdSUM, AVG, MIN, MAX, COUNT\n\n\xef\xbf\xbdWill often want to use GROUP BY and \n\nHAVING to filter our data\nSELECT publisher, SUM(price), COUNT(title)\n\nFROM Book\n\nGROUP BY publisher\n\nHAVING MIN(price) > 1.00;\n\n\n\nAggregation in SQL\n\n\xef\xbf\xbdHAVING applies a condition on the groups \n\nthemselves (after grouping), as opposed to a \n\ncondition in the WHERE clause which applies \n\nto the individual entries/tuples/rows\n\nSELECT publisher, SUM(price), COUNT(title)\n\nFROM Book\n\nWHERE price > 1.00\n\nGROUP BY publisher;\n\n\n\nQueries in SQL\n\n\xef\xbf\xbdTime to test your knowledge on a problem\n\nwhich uses everything we\xe2\x80\x99ve covered today\n\n(and more!)\n\n\n\nSELECT Game.genre,\nCOUNT(Hero.name)\n\nFROM Game, Hero\n\nWHERE Hero.level >= 1\nAND Hero.gameTitle = \nGame.title\n\nGROUP BY Game.genre\n\nHAVING MIN(Game.releaseYear) > 1999\n\nORDER BY Game.genre DESC;\n\nname gameTitle class level hitPoints\n\nMario Super Mario 64 Plumber 4 1\n\nLink Legend of Zelda: Wind \n\nWaker\n\nWarrior 1 3\n\nOlimar Pikmin 2 Thief 2 100\n\nKirby Kirby 64: The Crystal Shards Shapeshifter 5 50\n\nLeon Resident Evil 4 Gunner 3 200\n\nLuigi Luigi\xe2\x80\x99s Mansion Ghostbuster 0 5\n\nLouie Pikmin 2 Assistant 0 100\n\ntitle platform releaseYear genre\n\nSuper Mario 64 N64 1996 Platformer\n\nPikmin 2 Gamecube 2004 Puzzle\n\nLegend of Zelda: Wind Waker Gamecube 2003 Adventure\n\nKirby 64: The Crystal Shards N64 2000 Platformer\n\nLuigi\xe2\x80\x99s Mansion Gamecube 2001 Adventure\n\nResident Evil 4 Gamecube 2005 Adventure\n\n\n\nSELECT Game.genre,\nCOUNT(Hero.name)\n\nFROM Game, Hero\n\nWHERE Hero.level >= 1\nAND Hero.gameTitle = \nGame.title\n\nGROUP BY Game.genre\n\nHAVING MIN(Game.releaseYear) > 1999\n\nORDER BY Game.genre DESC;\n\nname gameTitle class level hitPoints platform release\nYear\n\ngenre\n\nMario Super Mario 64 Plumber 4 1 N64 1996 Platformer\n\nLink Legend of Zelda: Wind Waker Warrior 1 3 Gamecube 2003 Adventure\n\nOlimar Pikmin 2 Thief 2 100 Gamecube 2004 Puzzle\n\nLouie Pikmin 2 Assistant 0 100 Gamecube 2004 Puzzle\n\nKirby Kirby 64: The Crystal Shards Shapeshifter 5 50 N64 2000 Platformer\n\nLeon Resident Evil 4 Gunner 3 200 Gamecube 2005 Adventure\n\nLuigi Luigi\xe2\x80\x99s Mansion Ghostbuster 0 5 Gamecube 2001 Adventure\n\n*Note: here we do the Cartesian \nproduct and apply the title filter \nfrom the WHERE clause \nimmediately in order to keep the \ntable manageable. Observe that \nOlimar and Louie both matched \nwith the Game entry for Pikmin 2\n\n\n\nSELECT Game.genre,\nCOUNT(Hero.name)\n\nFROM Game, Hero\n\nWHERE Hero.level >= 1\nAND Hero.gameTitle = \nGame.title\n\nGROUP BY Game.genre\n\nHAVING MIN(Game.releaseYear) > 1999\n\nORDER BY Game.genre DESC;\n\nname gameTitle class level hitPoints platform release\nYear\n\ngenre\n\nMario Super Mario 64 Plumber 4 1 N64 1996 Platformer\n\nLink Legend of Zelda: Wind Waker Warrior 1 3 Gamecube 2003 Adventure\n\nOlimar Pikmin 2 Thief 2 100 Gamecube 2004 Puzzle\n\nLouie Pikmin 2 Assistant 0 100 Gamecube 2004 Puzzle\n\nKirby Kirby 64: The Crystal Shards Shapeshifter 5 50 N64 2000 Platformer\n\nLeon Resident Evil 4 Gunner 3 200 Gamecube 2005 Adventure\n\nLuigi Luigi\xe2\x80\x99s Mansion Ghostbuster 0 5 Gamecube 2001 Adventure\n\n\n\nSELECT Game.genre,\nCOUNT(Hero.name)\n\nFROM Game, Hero\n\nWHERE Hero.level >= 1\nAND Hero.gameTitle = \nGame.title\n\nGROUP BY Game.genre\n\nHAVING MIN(Game.releaseYear) > 1999\n\nORDER BY Game.genre DESC;\n\nname gameTitle class level hitPoints platform release\nYear\n\ngenre\n\nMario Super Mario 64 Plumber 4 1 N64 1996 Platformer\n\nKirby Kirby 64: The Crystal Shards Shapeshifter 5 50 N64 2000 Platformer\n\nOlimar Pikmin 2 Thief 2 100 Gamecube 2004 Puzzle\n\nLeon Resident Evil 4 Gunner 3 200 Gamecube 2005 Adventure\n\nLink Legend of Zelda: Wind Waker Warrior 1 3 Gamecube 2003 Adventure\n\n*Note: here I have reordered the entries \nby genre as the beginning of the GROUP BY \naction, but it is only finished once the \nentries are collapsed into single rows by \ngenre and once the desired attributes are \naggregated. I have extended this process \ninto several steps here so it is easier to see \nwhat\xe2\x80\x99s happening with the data in the \ntable and the various filters being applied\n\n\n\nSELECT Game.genre,\nCOUNT(Hero.name)\n\nFROM Game, Hero\n\nWHERE Hero.level >= 1\nAND Hero.gameTitle = \nGame.title\n\nGROUP BY Game.genre\n\nHAVING MIN(Game.releaseYear) > 1999\n\nORDER BY Game.genre DESC;\n\nname gameTitle class level hitPoints platform release\nYear\n\ngenre\n\nMario Super Mario 64 Plumber 4 1 N64 1996 Platformer\n\nKirby Kirby 64: The Crystal Shards Shapeshifter 5 50 N64 2000 Platformer\n\nOlimar Pikmin 2 Thief 2 100 Gamecube 2004 Puzzle\n\nLeon Resident Evil 4 Gunner 3 200 Gamecube 2005 Adventure\n\nLink Legend of Zelda: Wind Waker Warrior 1 3 Gamecube 2003 Adventure\n\n*Note: Mario and Kirby are grouped \ntogether in the Platformer genre, \nand this group\xe2\x80\x99s minimum release \nyear is Mario\xe2\x80\x99s 1996. Because this \ngroup does not meet the HAVING \ncondition, the whole group (including \nKirby) is filtered out\n\n\n\nSELECT Game.genre,\nCOUNT(Hero.name)\n\nFROM Game, Hero\n\nWHERE Hero.level >= 1\nAND Hero.gameTitle = \nGame.title\n\nGROUP BY Game.genre\n\nHAVING MIN(Game.releaseYear) > 1999\n\nORDER BY Game.genre DESC;\n\ngenre COUNT(Hero.name)\n\nAdventure 2\n\nPuzzle 1\n\n\n\nSELECT Game.genre,\nCOUNT(Hero.name)\n\nFROM Game, Hero\n\nWHERE Hero.level >= 1\nAND Hero.gameTitle = \nGame.title\n\nGROUP BY Game.genre\n\nHAVING MIN(Game.releaseYear) > 1999\n\nORDER BY Game.genre DESC;\n\ngenre COUNT(Hero.name)\n\nPuzzle 1\n\nAdventure 2\n\n*Note: ORDER BY - DESC sorts the \nvalues in decreasing/descending order. \nFor a string, this means the opposite of \nalphabetical order, like in java. We also \nhave ASC for ascending order, which is \nthe default of ORDER BY. \n\n\n\nThese slides were made referencing \nthe course slides from Prof Shiri, as \nwell as the textbook: \nA First Course in Database Systems by \nUllman and Widom, third edition\n\n\n'