b'\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMicrosoft PowerPoint - DB9.ppt [Compatibility Mode]\n\n\n1\n\nCOMP353 Databases\n\nMore on SQL:\n\nNested Querie Nested Querie Nested Querie Nested Querie \n\nViewsViewsViewsViews\n\n1\n\nScalar Values\n\n\xef\xbf\xbd An SQL query is an expression that evaluates to a \n\ncollection of tuples, i.e., it produces a relation/bag\n\n\xef\xbf\xbd This \xe2\x80\x9ccollection\xe2\x80\x9d may have only one attribute\n\n\xef\xbf\xbd It is also possible that there will be only one single \n\nvalue produced for that attribute\n\n\xef\xbf\xbd If all these hold, then we say that the query \n\nproduces a scalar value\n\n\xef\xbf\xbd Scalar values \xe2\x80\x93 example include simple values such \n\nas integers, reals, strings, dates, etc.\n2\n\nQueries that Produce Scalar Values\n\n\xef\xbf\xbd Relation schema:\nMovie( title, year, length, filmType, studioName, producerC# )\n\n\xef\xbf\xbd Query:\nFind certificate number of the producer of \xe2\x80\x9cStar Wars\xe2\x80\x9d\n\n\xef\xbf\xbd Query in SQL:\nSELECT producerC#\n\nFROMMovie\n\nWHERE title = \xe2\x80\x99Star Wars\xe2\x80\x99;\n\nAssuming that we have only one such movie.\n\n3\n\nSubqueries\n\n\xef\xbf\xbd Conditions in the WHERE clause may have comparisons that \n\ninvolve scalar values\n\n\xef\xbf\xbd A SQL query can produce a scalar value\n\n\xef\xbf\xbd If so, we can use such SELECT-FROM-WHERE expression, \n\nsurrounded by parentheses, as if it were a constant\n\n\xef\xbf\xbd Subquery \xe2\x80\x93 a query within a query\n\nThe result of a SQL subquery is a collection (relation/bag)\n\n4\n\nExample\n\n\xef\xbf\xbd Relation schemas:\nMovie (title, year, length, filmType, studioName, producerC#)\n\nExec (name, address, cert#, netWorth)\n\n\xef\xbf\xbd Query:\nFind the name of the producer of \xe2\x80\x9cStar Wars\xe2\x80\x9d\n\n\xef\xbf\xbd Query in SQL:\nSELECT Exec.name\n\nFROMMovie, Exec\n\nWHERE Movie.title = \xe2\x80\x99Star Wars\xe2\x80\x99 AND\n\nMovie.producerC# = Exec.cert#;\n\n5\n\nExample\n\n\xef\xbf\xbd Relation schemas:\nMovie (title, year, length, filmType, studioName, producerC#)\n\nExec (name, address, cert#, netWorth)\n\n\xef\xbf\xbd Query:\nFind the name of the producer of \xe2\x80\x9cStar Wars\xe2\x80\x9d\n\n\xef\xbf\xbd Query with Subquery:\nSELECT name\n\nFROM Exec\n\nWHERE cert# = ( SELECT producerC#\n\nFROMMovie\n\nWHERE title = \xe2\x80\x99Star Wars\xe2\x80\x99 );\n6\n\n\n\n2\n\nConditions Involving Relations\n\n\xef\xbf\xbd There are a number of SQL checks/conditions that \n\ncan be done on a relation R and produce a boolean\n\nvalue \n\n\xef\xbf\xbd These conditions can be negated by putting a NOT\n\nbefore them\n\n\xef\xbf\xbd Typically, R above is the result of an SQL subquery, \n\nshown as: (R)\n\n\xef\xbf\xbd If such a condition involves a scalar value s or a \n\ntuple, we should make sure its type matches R.\n7\n\nConditions Involving Relations\n\n\xef\xbf\xbd \xe2\x80\x9cEXISTS (R)\xe2\x80\x9d is a condition that is true iff R is not empty\n\n\xef\xbf\xbd \xe2\x80\x9cs IN (R)\xe2\x80\x9d is true iff s is equal to one of the values in R\n\n\xef\xbf\xbd \xe2\x80\x9cs NOT IN (R)\xe2\x80\x9d is true iff s is not equal to any  value in R\n\n\xef\xbf\xbd \xe2\x80\x9cS >>>> ALL (R)\xe2\x80\x9d is true iff s is greater than every value in R\n\n\xef\xbf\xbd \xe2\x80\x9c>>>>\xe2\x80\x9d could be replaced by other operators with the analogous \n\nmeaning\n\n\xef\xbf\xbd Note: \xe2\x80\x9cs <> ALL (R)\xe2\x80\x9d is the same as \xe2\x80\x9cs NOT IN R\xe2\x80\x9d\n\n\xef\xbf\xbd \xe2\x80\x9cs >>>> ANY (R)\xe2\x80\x9d is true iff s is >>>> at least one value in R\n\n\xef\xbf\xbd \xe2\x80\x9c>>>>\xe2\x80\x9d could be replaced by any of the other 5 comparison operators \n\nwith the analogous meaning\n\n\xef\xbf\xbd Note: \xe2\x80\x9cs = ANY (R)\xe2\x80\x9d is the same as \xe2\x80\x9cs IN R\xe2\x80\x9d 8\n\nConditions Involving Tuples\n\xef\xbf\xbd A tuple in SQL is represented by a parenthesized list of \n\nscalar values; the concept \xe2\x80\x9ctuple\xe2\x80\x9d can be viewed as an \n\nextension of the concept of scalar;\n\n\xef\xbf\xbd (123, \xe2\x80\x99foo\xe2\x80\x99)\n\n\xef\xbf\xbd Mixing of constants and attributes is also permitted in tuples\n\n\xef\xbf\xbd (123, Movie.title)\n\n\xef\xbf\xbd If a tuple t has the same number of components as a relation \n\nR, then it makes sense to compare t and R like:\n\n\xef\xbf\xbd t  IN (R)  -- this is true iff t is in R\n\n\xef\xbf\xbd t <> ANY (R) -- this is true R includes a tuple other than t\n\n9\n\nExample\n\xef\xbf\xbd Relation schemas:\n\nMovie (title, year, length, filmType, studioName, producerC#)\n\nExec (name, address, cert#, netWorth)\n\nStarsIn (title, year, starName)\n\n\xef\xbf\xbd Query: Find the names of the producers of Harrison Ford\xe2\x80\x99s movies\n\n\xef\xbf\xbd Query in SQL:\nSELECT name\nFROM Exec\n\nWHERE cert# IN (SELECT producerC#\nFROMMovie\n\nWHERE (title, year) IN (SELECT title, year\nFROM StarsIn\n\nWHERE starName = \xe2\x80\x99Harrison Ford\xe2\x80\x99)); 10\n\nExample\n\xef\xbf\xbd Relation schemas:\n\nMovie(title, year, length, filmType, studioName, producerC#)\n\nExec(name, address, cert#, netWorth)\n\nStarsIn(title, year, starName)\n\n\xef\xbf\xbd Query:Find names of the producers of Harrison Ford\xe2\x80\x99s movies\n\n\xef\xbf\xbd Query in SQL:\nSELECT Exec.name\n\nFROM Exec, Movie, StarsIn\n\nWHERE Exec.cert# = Movie.producerC# AND \n\nMovie.title = StarsIn.title AND\n\nMovie.year = StarsIn.year AND \n\nstarName = \xe2\x80\x99Harrison Ford\xe2\x80\x99;\n11\n\nCorrelated Subqueries\n\xef\xbf\xbd Simple subqueries can be evaluated once and the result be \n\nused in a higher level (calling) query\n\n\xef\xbf\xbd A more complex use of nested subquery requires the \n\nsubquery to be evaluated many times, once for each \n\nassignment of a value (to some term in the subquery) that \n\ncomes from a tuple variable in the calling query\n\n\xef\xbf\xbd A subquery of this type is called correlated subquery\n\n12\n\n\n\n3\n\nCorrelated Subqueries\n\n\xef\xbf\xbd Relation schema:\nMovie(title, year, length, filmType, studioName, producerC#)\n\n\xef\xbf\xbd Query:\nFind movie titles that appear more than once\n\n\xef\xbf\xbd Query in SQL:\nSELECT title\n\nFROMMovie Old\n\nWHERE year < ANY (SELECT year\n\nFROM Movie\n\nWHERE title = Old.title);\n\nNote the scopes of the variables in this query.\n13\n\nCorrelated Subqueries\n\xef\xbf\xbd Query in SQL\n\nSELECT title\n\nFROMMovie Old\n\nWHERE year <<<< ANY (SELECT year\n\nFROM Movie\n\nWHERE title = Old.title);\n\n\xef\xbf\xbd The condition in the outer WHERE is true only if there is a movie with  same \n\ntitle as Old.title that has a later year \n\n\xef\xbf\xbd The query will produce a title one fewer times than there are movies with that title\n\n\xef\xbf\xbd What would be the result if we used \xe2\x80\x9c<><><><>\xe2\x80\x9d, instead of \xe2\x80\x9c<<<<\xe2\x80\x9d ?\n\n\xef\xbf\xbd For a movie title appearing 3 times, we would get 3 copies of the title in the output\n\n14\n\nViews\n\xef\xbf\xbd View is a table/relation defined in a database but has no tuples \n\nexplicitly stored for it in the database but rather computed, when \n\nneeded, from the view definition\n\n\xef\xbf\xbd The view mechanism provides support for:\n\n\xef\xbf\xbd Logical data independence:\n\n\xe2\x80\xa2 Views can be used to define relations in the external schema that mask, from \n\nthe applications/users, changes in the conceptual database schema\n\n\xe2\x80\xa2 If the schema of a relation is changed, we can define a view with \n\nthe old schema so that applications that use the old schema can \n\ncontinue using it \n\n\xef\xbf\xbd Security:\n\n\xe2\x80\xa2 Views can be used to restricts the users access only the information they are \n\nallowed to \xe2\x80\x9csee and operate on\xe2\x80\x9d\n15\n\nViews\n\n\xef\xbf\xbd Relation schema:\nMovie(title, year, length, filmType, studioName, producerC#)\n\n\xef\xbf\xbd View:\nCreate the Paramount\xe2\x80\x99s movies (title and year)\n\n\xef\xbf\xbd View in SQL:\nCREATE VIEW ParamountMovie AS\n\nSELECT title, year\n\nFROM Movie\n\nWHERE studioName = \xe2\x80\x99Paramount\xe2\x80\x99;\n\n16\n\nViews\n\n\xef\xbf\xbd A view can be used in defining new queries/views in exactly \n\nthe same way as an explicitly stored table may be used \n\n\xef\xbf\xbd Example to query the (virtual) relation ParamountMovie\n\nSELECT title\n\nFROM ParamountMovie\n\nWHERE year = 1979;\n\n\xef\xbf\xbd This query is translated, by the query processor, into:\n\nSELECT title\n\nFROM Movie\n\nWHERE studioName = \xe2\x80\x99Paramount\xe2\x80\x99 AND year = 1979;\n17\n\nViews\n\n\xef\xbf\xbd Relation schema:\nParamountMovie (title, year )\n\nStarsIn(title, year, starName)\n\n\xef\xbf\xbd Query:\nList the stars of the movies made by Paramount.\n\n\xef\xbf\xbd Query in SQL\nSELECT DISTINCT StarsIn.starName\n\nFROM ParamountMovie, StarsIn\n\nWHERE ParamountMovie.title = StarsIn.title AND\n\nParamountMovie.year = StarsIn.year;\n\n18\n\n\n\n4\n\nViews\n\n\xef\xbf\xbd Relation schema:\nMovie (title, year, length, filmType, studioName, producerC#)\n\nExec (name, address, cert#, netWorth)\n\n\xef\xbf\xbd View:\nDefine a view of Movie (titles and executives/producers)\n\n\xef\xbf\xbd View in SQL:\nCREATE VIEW MovieProd AS\n\nSELECT Movie.title, Exec.name\n\nFROMMovie, Exec\n\nWHERE Movie.producerC# = Exec.cert#;\n\n19\n\nViews\n\n\xef\xbf\xbd Relation schema:\nMovieProd (title, name)\n\n\xef\xbf\xbd Query:\nFind the name of the producer of \xe2\x80\x98Gone With the Wind\xe2\x80\x99?\n\n\xef\xbf\xbd Query in SQL:\nSELECT name\n\nFROMMovieProd\n\nWHERE title = \xe2\x80\x99Gone With the Wind\xe2\x80\x99;\n\n20\n\nViews\n\n\xef\xbf\xbd Renaming attributes used in view definitions\n\xef\xbf\xbd We can give new names to view attributes rather than \n\nusing the names that come out of query defining the view\n\n\xef\xbf\xbd Example:\nCREATE VIEW MovieProd (MovieTitle, ProducerName) AS\n\nSELECT Movie.title, Exec.name\n\nFROMMovie, Exec\n\nWHERE Movie.producerC# = Exec.cert#;\n\n21\n\nViews\n\n\xef\xbf\xbd Relation schema:\nMovieProd (MovieTitle, ProducerName)\n\n\xef\xbf\xbd Query:\nFind the name of the producer of \xe2\x80\x98Gone With the Wind\xe2\x80\x99?\n\n\xef\xbf\xbd Query in SQL:\nSELECT ProducerName\n\nFROMMovieProd\n\nWHERE MovieTitle = \xe2\x80\x99Gone With the Wind\xe2\x80\x99;\n\n22\n\nUpdating Views?\n\n\xef\xbf\xbd We saw that a view can appear in a query in exactly \nthe same way as a \xe2\x80\x9cbase\xe2\x80\x9d table may appear.\n\n\xef\xbf\xbd What about modifications/updates?\n\n\xef\xbf\xbd What does it mean to update a view?\n\xef\xbf\xbd Translate modification of the view to the corresponding \n\nmodification on the base tables used in the view definition\n\n\xef\xbf\xbd Should we allow updates on views?\n\xef\xbf\xbd Yes, in principle, but some problems may arise\n\n\xef\xbf\xbd Some \xe2\x80\x9csimple\xe2\x80\x9d views can be updated\n\xef\xbf\xbd Such views are called updatable views\n\n\xef\xbf\xbd Many views cannot be updated\n\xef\xbf\xbd This is due to the so called view-update anomaly\n\n23\n\nInsertion into Views?\n\xef\xbf\xbd Relation schema:\n\nMovie(title, year, length, filmType, studioName, producerC#)\n\n\xef\xbf\xbd View: Recall the definition of ParamountMovie\nCREATE VIEW ParamountMovie AS\n\nSELECT title, year\n\nFROM Movie\n\nWHERE studioName = \xe2\x80\x99Paramount\xe2\x80\x99;\n\n\xef\xbf\xbd Update statement:\n\nINSERT INTO ParamountMovie (title,year) VALUES(\xe2\x80\x99KK\xe2\x80\x99, 2002);\n\n\xef\xbf\xbd Result: the following tuple being added to Movie\n\n(\xe2\x80\x99KK\xe2\x80\x99, 2002, NULL, NULL, NULL, NULL)   What\xe2\x80\x99s the problem? 24\n\n\n\n5\n\nInsertion into Views?\n\xef\xbf\xbd Relation schema:\n\nMovie(title, year, length, filmType, studioName, producerC#)\n\n\xef\xbf\xbd An updatable view:\nCREATE VIEW ParamountMovie AS\n\nSELECT title, year, studioName\n\nFROM Movie\n\nWHERE studioName = \xe2\x80\x99Paramount\xe2\x80\x99;\n\n\xef\xbf\xbd Update statement:\n\nINSERT INTO ParamountMovie VALUES(\xe2\x80\x99KK\xe2\x80\x99,2002,\xe2\x80\x99Paramount\xe2\x80\x99);\n\n\xef\xbf\xbd Result: the following tuple is being added to Movie\n\n(\xe2\x80\x99KK\xe2\x80\x99, 2002, NULL, NULL, \xe2\x80\x99Paramount\xe2\x80\x99, NULL)  Problem solved! 25\n\nInsertion into Views?\n\xef\xbf\xbd Relation schemas:\n\nMovie(title, year, length, filmType, studioName, producerC# )\n\nExec(name, address, cert# , netWorth)\n\n\xef\xbf\xbd View in SQL:\nCREATE VIEW MovieProd AS\n\nSELECT Movie.title, Exec.name\n\nFROM Movie, Exec\n\nWHERE Movie.producerC# = Exec.cert#;\n\n\xef\xbf\xbd Update statement\n\nINSERT INTO MovieProd (title,name) VALUES(\xe2\x80\x99The Movie\xe2\x80\x99, \xe2\x80\x99J. Smith\xe2\x80\x99);\n\n\xef\xbf\xbd Result: these tuples are added to the corresponding relations:\n\nMovie(\xe2\x80\x99The Movie\xe2\x80\x99, NULL, NULL, NULL, NULL, NULL) \n\nExec(\xe2\x80\x99J. Smith\xe2\x80\x99, NULL, NULL, NULL)     Problems? The insertion command will fail !\n\n26\n\nDeletion from Views?\n\n\xef\xbf\xbd Relation schema:\nMovie(title, year, length, filmType, studioName, producerC#)\n\n\xef\xbf\xbd View: Recall the definition :\nCREATE VIEW ParamountMovie AS\n\nSELECT title, year, studioName\n\nFROM Movie\n\nWHERE studioName = \xe2\x80\x99Paramount\xe2\x80\x99;\n\n\xef\xbf\xbd Delete statement:\n\nDELETE FROM ParamountMovie WHERE title LIKE \xe2\x80\x99%K%\xe2\x80\x99;  \n\n\xef\xbf\xbd Translated query:\n\nDELETE FROM Movie \n\nWHERE studioName = \xe2\x80\x99Paramount\xe2\x80\x99 AND title LIKE \xe2\x80\x98%K%\xe2\x80\x99;\n27\n\nUpdating Views?\n\n\xef\xbf\xbd Relation schema:\nMovie(title, year, length, filmType, studioName, producerC#)\n\n\xef\xbf\xbd View:\nCREATE VIEW ParamountMovie AS\n\nSELECT title, year,studioName\n\nFROM Movie\n\nWHERE studioName = \xe2\x80\x99Paramount\xe2\x80\x99; \n\n\xef\xbf\xbd The view update statement:\n\nUPDATE ParamountMovie SET year = 1797 WHERE title =\xe2\x80\x98KK\xe2\x80\x99;\n\n\xe2\x80\xa2 We may drop a view: DROP VIEW ParamountMovie; \n28\n\nUpdating Views?\n\n\xef\xbf\xbd Recall: updating views includes insertion, deletion, and changing data\n\n\xef\xbf\xbd SQL provides a formal definition of when modifications to a view are \n\npermitted\n\n\xef\xbf\xbd Roughly, this is permitted when the view is defined by selecting some \n\nattributes from one relation R, which could be an \xe2\x80\x9cupdatable\xe2\x80\x9d view itself\n\n\xef\xbf\xbd The list in the SELECT clause includes \xe2\x80\x9cenough\xe2\x80\x9d attributes that for every tuple \n\ninserted into the view, the tuple inserted into the base relation will \xe2\x80\x9cyield\xe2\x80\x9d the \n\ninserted tuple of the view \n\n\xef\xbf\xbd The NOT NULL constraints on the base table will not be violated\n\n\xef\xbf\xbd The view definition uses SELECT (but not  SELECT DISTINCT) \n\n\xef\xbf\xbd The WHERE clause does not involve R in a subquery\n\n29\n\n\n'