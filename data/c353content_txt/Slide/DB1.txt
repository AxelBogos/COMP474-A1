b'Databases                                 Concordia University                Computer Science and Software Engineering                                 COMP353: Databases                                      Winter 2020-2021 (REMOTE)   Instructor:    Khaled Jababo (jababo@cse.concordia.ca) Lectures:     Mo-We  10:15 \xe2\x80\x93 11:30 Online Office hour: We   11:30 \xe2\x80\x93 12:30 Online  mailto:jababo@cse.concordia.ca2 Introduction to Databases and SQL  What is a Database?   \xef\x81\xae A database is a collection of data that exists over a long period of time (Persistent storage) \xef\x81\xae This collection should be logically coherent and have some inherent meaning, typically about an enterprise \xef\x83\xa8 it may not be a random pile of data  3 Examples of Databases  \xef\x81\xae List of names, addresses, and phone numbers of your friends \xef\x81\xae Information about employees, departments, salaries, managers, etc. in a COMPANY \xef\x81\xae Information about students, courses, grades, professors, etc. in a UNIVERSITY \xef\x81\xae Information about books, users, etc. in a LIBRARY 4 Database Management System (DBMS)  \xef\x81\xae A DBMS is a complex software package developed to store and \xe2\x80\x9cmanage\xe2\x80\x9d databases \xef\x81\xae Note the distinction between DB, DBS, and DBMS:    Database system = Database + DBMS  5 What does a DBMS provide?  \xef\x81\xae Supports convenient, efficient, and secure access and manipulation of large amounts of data \xef\x81\xae (high-level) Programming interface: Gives users the ability to create, query, and modify the data \xef\x81\xae Persistent storage: Supports the storage of data over a long period of time  \xef\x81\xae Transaction management and recovery: Controls access to shared data from multiple, simultaneous users with properties Atomicity, Consistency, Isolation, Durability (ACID) 6 File Processing Systems (FPS)  Customer  Master File OS Customer list User 1 Application Program 1 PLI Cust-No Cust-Name Address Credit-Code Description  Invoice  Master File OS Monthly invoice User 2 Application Program 2 COBOL Cust-No Cust-Name Address Part-No Qty-Ordered Price Part-No Part-Descr Vendor-No Qty-In-Stock Qty-On-Order  Inventory  Master File OS Parts list User 3 Application Program 3 PASCAL 7 Disadvantages of FPS \xef\x81\xae Redundancy of data: Identical data are distributed over various files \xe2\x80\x93 a major source of problems  \xef\x81\xae Waste of storage space: When the same field is stored in several files, the required storage space is needlessly high \xef\x83\xa8 high storage cost  \xef\x81\xae Multiple updates: One field may be updated in one file but not in others \xef\x83\xa8 inconsistency and lack of data integrity and hence potential conflicting reports \xef\x81\xae Multiple programming languages: Dealing with several programming languages which are often not user friendly \xef\x83\xa8 high system maintenance cost 8 Database Systems  Database   Customer list User 1 Monthly invoice User 2 Parts list User 3 OS Data Items : Cust-No Cust-Name Address Credit-Code Description Part-No Qty-Orderd Price Part-descr Vendor-No Qty-In-Stock Qty-On-Order Query  Language DBMS Routines Data  Manipulation Language 9 Advantages of Databases \xef\x81\xae Minimize data redundancy and avoid inconsistency     They provide:  \xef\x81\xae Concurrent access to shared data \xef\x81\xae Centralized control over data management \xef\x81\xae Security and authorization \xef\x81\xae Integrity and reliability \xef\x81\xae Data abstraction and independence 10 Aspects of Database Studies \xef\x81\xaeModeling and design of databases \xef\x83\xbc \xef\x81\xae Database programming \xef\x83\xbc \xef\x81\xae DBMS implementation    The first two aspects are studied in COMP 353      The third one is studied in COMP 451  11 What is this course about?  \xef\x81\xae A database is a \xe2\x80\x9ccollection of data.\xe2\x80\x9d This data is managed by a DBMS \xef\x81\xae  Databases are essential today to support commercial, engineering, and scientific applications.   \xef\x81\xae They are at the core of many scientific investigations.  \xef\x81\xae Their power comes from a rich body of knowledge and technology developed over several decades \xef\x81\xae In this course, we study fundamental concepts, techniques, and tools for database design and programming. \xef\x81\xae In COMP451, we study details of DB implementation 12 A  quick test! \xef\x81\xae Which one of the following is the main source of the problems in file processing systems, addressed by databases? A. Waste of storage space. B. Update anomalies, which result in lack of data integrity. C. Data redundancy. D. Data inconsistency. 13 Data Modeling and  Database Design An Overview 14 Types of Data Models \xef\x81\xae  A Data Model is a collection of concepts, describing  \xef\x81\xae data and relationships among data  \xef\x81\xae data semantics and data constraints \xef\x81\xae Entity-Relationship (ER) Model \xef\x83\x96  \xef\x81\xae Relational Model \xef\x83\x96 \xef\x81\xae Object-Oriented Data Model (ODL) \xef\x83\x96  \xef\x81\xae Logical Data Model (Datalog) \xef\x83\x96  \xef\x81\xae  Earlier \xe2\x80\x9crecord\xe2\x80\x9d based Data Models \xef\x81\xae Network \xef\x81\xae Hierarchical  15 Relational Model \xef\x81\xae Data is organized in relations (tables)    The user should/need not be concerned with the underlying storage data structure. \xef\x81\xae Relational database schema:  \xef\x81\xae Set of table names \xe2\x80\x93  D = {R1,\xe2\x80\xa6,Rn} \xef\x81\xae Set of attributes for each table \xe2\x80\x93  Ri = {A1,\xe2\x80\xa6,Ak} \xef\x81\xae Examples of tables:  \xef\x81\xae Account=  {accNum, branchNam, amount, customerId} \xef\x81\xae Movie= {title, year, director, studio} 16 Relational Model  \xef\x81\xae Most widely used model \xef\x81\xae Vendors: Oracle, IBM, Informix, Microsoft, Sybase, etc. \xef\x81\xae Competitor: object-oriented model  \xef\x81\xae ObjectStore, Postgres, etc.  \xef\x81\xae Another approach: object-relational model 17 Objectives of Database Systems  \xef\x81\xae A DB system should be simple, so that many users with little skills could interact with the system  conveniently \xef\x81\xae It should be complex, so that many (complex) queries and transactions could be handled/processed efficiently  But these objectives are contradictory! So how to achieve both? 18 Three Views of Data Employee name Employee address SIN Annual salary Employee name: string    SIN: dec, key Employee address: string Employee health card No: string, unique Annual salary: float Employee name: string length 25 offset 0         SIN: 9 dec offset 25 unique Employee health card No: string length 10 offset 34  unique Employee address: string length 51 offset 44 Annual salary: 9,2 dec offset 95 External view Conceptual view Internal view User 1 Database Administrator (DBA) User 2 19 Three Views / Levels of Data \xef\x81\xae Internal  (physical) level A block of consecutive bytes actually holding the data \xef\x81\xae  Conceptual (logical) level type emp = record  SIN : integer;  name : string;  address : string;  salary : real;  healthCard  : string; end  \xef\x81\xae External (logical) level View 1 : (emp.name, emp.address) View 2 : (emp.SIN, emp.salary) 20 Levels of Abstraction in DB\xe2\x80\x99s \xef\x81\xae Views describe how users \xe2\x80\x9csee\xe2\x80\x9d the data \xef\x81\xae Conceptual schema defines logical structure \xef\x81\xae Physical schema describes the storage structure of data and the indexes  View 1 View 2 View 3 Conceptual Schema  Physical Schema  Abstraction is achieved through describing each level in terms of a schema using a particular data model 21 Schemas at different levels of abstraction \xef\x81\xae View (or External users): are typically determined during requirements analysis (often defined as views over some of the concepts in the logical DB schema) \xef\x81\xae Conceptual (or Logical) Schema: an outcome of a database design (a main focus in this course) \xef\x81\xae Physical Schema: storage and index structures associated with relations 22 Schemas and Instances \xef\x81\xae A database instance is the current content of the DB \xef\x81\xae A database schema is the structure of the data (relations/classes), described in some suitable data model e.g. relation:         Students {sid, name, department, dob, address}  rep. as a set  or     Students (sid, name, department, dob, address)  as a tuple   Students  sid name department dob address 1112223 John Smith CS 12-01-82 22 Pine, #1203 2223334 Ali  Brown EE 31-08-73 2000 St. Marc 3334445 Sana Kordi  CS 23-11-79 1150 Guy  23 Data Independence \xef\x81\xae Defn: the ability to modify definition of schema at one level with little or no affect on the schema (s) at a higher level \xef\x81\xae Achieved through the use of three levels of data abstraction  \xef\x81\xae Logical Data Independence \xef\x81\xae Ability to modify logical schema with little or no affect/change to rewrite the application programs \xef\x81\xae E.g., adding new fields to a record or changing the type of a field \xef\x81\xae Physical Data Independence \xef\x81\xae Ability to modify physical schema with little or no  impact on the conceptual schema or the application programs, i.e., the possibility of having separate schemas at the physical and conceptual levels \xef\x81\xae E.g., changing a file structure from sequential to direct access 24 DBMS Implementation Overview 25 Query  Processor Schema  Modifications Transaction  Manager Storage  Manager Data Metadata Queries Transactions Architecture of a DBMS \xef\x81\xae There are 3 types of inputs to DBMS: \xef\x81\xae Queries \xef\x81\xae Transactions, i.e.,       data Modifications \xef\x81\xae Schema Creations/ Modifications 26 Architecture of a DBMS \xef\x81\xae The query processor handles: \xef\x81\xae Queries \xef\x81\xae Modifications (of both data and schema) \xef\x81\xae The job of the query processor + query optimizer (QO) is \xef\x81\xae To find the \xe2\x80\x9cbest\xe2\x80\x9d plan to process the query \xef\x81\xae To issue commands to storage/buffer manager Query  Processor Schema  Modifications Transaction  Manager Storage  Manager Data Metadata Queries Modifications 27 Architecture of a DBMS \xef\x81\xae The job of the storage manager is  \xef\x81\xae To obtain information requested from the data storage \xef\x81\xae To modify the information to the data storage when requested. Query  Processor Schema  Modifications Transaction  Manager Storage  Manager Data Metadata Queries Modifications 28 Architecture of a DBMS \xef\x81\xae The transaction manager is responsible for the consistency of the data  \xef\x81\xae The job of the transaction manager is to ensure: \xef\x81\xae several queries running simultaneously do not \xe2\x80\x9cinterfere\xe2\x80\x9d with each other  \xef\x81\xae Integrity of the data data even if there is a power failure (Recovery system) Query  Processor Schema  Modifications Transaction  Manager Storage  Manager Data Metadata Queries Modifications 29 Architecture of a DBMS \xef\x81\xae A representation of data and other relevant information on disk  \xef\x81\xae It contains: \xef\x81\xae Data \xef\x81\xae Metadata Query  Processor Schema  Modifications Transaction  Manager Storage  Manager Data + Metadata Queries Modifications 30 Users of a Database System DBMS and  its data manager Query  processor OS or own file manager DDL compiler Compiled application program    Data + MetaData + Indexes OS disk manager Compiled user interface Telecom system Telecom system Telecom system Naive user Application developer DBA Specialized user 31 Database Programming Overview 32 Database Languages \xef\x81\xae A Database Management System (DBMS) provides two types of languages, which may also     be viewed as components of the DBMS language: \xef\x81\xae Data Definition Language (DDL) \xe2\x80\xa2 Language (notation) for defining a database schema  \xe2\x80\xa2 It includes syntax for declaring tables, indexes, views, constraints, etc.) \xef\x81\xae Data Manipulation Language (DML) \xe2\x80\xa2 Language for accessing and manipulating the data (organized/stored according to the appropriate data model) 33 Query Languages \xef\x81\xae Commercial: \xef\x81\xae SQL\xef\x83\x96 \xef\x81\xae Theoretical/Abstract: \xef\x81\xae Relational Algebra \xef\x83\x96 \xef\x81\xae Relational Calculus \xef\x81\xae Datalog \xef\x83\x96  34 SQL  \xef\x81\xae Developed originally at IBM in 1976 \xef\x81\xae First standard: SQL-86  \xef\x81\xae Second standard: SQL-92  \xef\x81\xae Other standards: SQL-99, or SQL3, well over 1,000 page doc. \xef\x81\xae Currently SQL-2019 which supports MultiDim. Arrays \xef\x81\xae De-facto standard of the relational database world; replaced all other DB languages  \xef\x81\xae The SQL query language components: \xef\x81\xae DDL \xef\x81\xae DML 35 Simple SQL Queries \xef\x81\xae A SQL query has a form:  SELECT . . . FROM . . . WHERE . . . ; \xef\x81\xae The SELECT clause indicates which attributes should appear in the output. \xef\x81\xae The FROM gives the relation(s) the query refers to \xef\x81\xae The WHERE clause is a Boolean expression indicating which tuples are of interest. \xef\x81\xae A query result is a bag, in general \xef\x81\xae A query result is unnamed. 36 Example SQL Query  \xef\x81\xae Relation schema: Course (courseNumber, name, noOfCredits) \xef\x81\xae Query: Find all the courses stored in the database \xef\x81\xae Query in SQL: SELECT \xef\x80\xaa FROM Course;   Note: \xe2\x80\x9c \xef\x80\xaa \xe2\x80\x9c means all attributes in the relation(s) involved. 37 Example SQL Query  \xef\x81\xae Relation schema: Movie (title, year, length, filmType) \xef\x81\xae Query: Find the titles of all movies stored in the database \xef\x81\xae Query in SQL: SELECT title FROM Movie;  38 Example SQL Query  \xef\x81\xae Relation schema: Student (ID, firstName, lastName, address, GPA) \xef\x81\xae Query: Find the ID of every student whose GPA is more than 3  \xef\x81\xae Query in SQL: SELECT ID FROM Student WHERE GPA > 3;  39 Example SQL Query  \xef\x81\xae Relation schema: Student (ID, firstName, lastName, address, GPA) \xef\x81\xae Query: Find the ID and last name of every student with first name \xe2\x80\x99John\xe2\x80\x99,  who has a GPA > 3  \xef\x81\xae Query in SQL: SELECT ID, lastName FROM Student WHERE firstName = \xe2\x80\x99John\xe2\x80\x99 AND GPA > 3;  40 WHERE clause \xef\x81\xae The expressions that may follow WHERE are conditions \xef\x81\xae Standard comparison operators \xce\x98 includes { =, <>, <, >, <=, >= } \xef\x81\xae The values that may be compared include constants and attributes of the relation(s) mentioned in FROM clause \xe2\x80\xa2 Simple expression \xe2\x80\xa2 A op Value \xe2\x80\xa2 A op B where A, B are attributes and op is a comparison operator  \xef\x81\xae We may also apply the usual arithmetic operators, +,-,*,/, etc. to numeric values before comparing them  \xe2\x80\xa2 (year - 1930) * (year - 1930) \xef\x80\xbc 100 \xef\x81\xae The result of a comparison is a Boolean value, TRUE or FALSE  \xef\x81\xae Boolean expressions can be combined by the logical operators AND, OR, and NOT  41 Example SQL Query  \xef\x81\xae Relation schema: Movie (title, year, length, filmType) \xef\x81\xae Query: Find the titles of all color movies produced in 1990 \xef\x81\xae Query in SQL: SELECT title FROM Movie WHERE filmType = \xe2\x80\x99color\xe2\x80\x99 AND year = 1990;  42 Example SQL Query  \xef\x81\xae Relation schema: Movie (title, year, length, filmType) \xef\x81\xae Query:  Find the titles of color movies that are either made after 1970 or  are less than 90 minutes long \xef\x81\xae Query in SQL: SELECT title FROM Movie WHERE (year > 1970 OR length < 90) AND filmType = \xe2\x80\x99color\xe2\x80\x99;  \xef\x81\xae Note the precedence rules, when parentheses are absent: AND takes precedence over OR, and  NOT takes precedence over AND and OR 43 Products and Joins  \xef\x81\xae SQL has a simple way to \xe2\x80\x9ccouple\xe2\x80\x9d relations in one query \xef\x81\xae How? By \xe2\x80\x9clisting\xe2\x80\x9d the relevant relation(s) in the FROM clause  \xef\x81\xae All the relations in the FROM clause are coupled through Cartesian product (shown as \xef\x82\xb4 in algebra notation) 44 Cartesian Product \xef\x81\xae From Set Theory: \xef\x81\xae The Cartesian Product of two sets R and S is the set of all pairs (a, b) such that: a \xe2\x88\x88 R and b \xe2\x88\x88 S. \xef\x81\xae Denoted as R \xef\x82\xb4 S  \xef\x81\xae Note: \xe2\x80\xa2 In general, R \xef\x82\xb4 S \xef\x82\xb9 S \xef\x82\xb4 R 45 A  quick test! \xef\x81\xae Let R(A1,\xe2\x80\xa6,An) be a relation schema and r be any instance of R. Suppose r has m tuples. Which of the following is the number of ways in which r may be represented in the relational model?  A. m * n  B. 2m  C. m! * n! D. 2n  46 Example Instance S: Instance R: R x S: B C D 2 5 6 4 7 8 9 10 11 A B 1 2 3 4 A R.B S.B C D 1 2 2 5 6 1 2 4 7 8 1 2 9 10 11 3 4 2 5 6 3 4 4 7 8 3 4 9 10 11 47 Example Instance of Course: Instance of Student: SELECT \xef\x80\xaa FROM Student, Course; ID firstName lastName GPA Address courseNumber name noOfCredits 111 Joe Smith 4.0 45 Pine av. Comp352 Data structures 3 111 Joe Smith 4.0 45 Pine av. Comp353 Databases 4 222 Sue Brown 3.1 71 Main st. Comp352 Data structures 3 222 Sue Brown 3.1 71 Main st. Comp353 Databases 4 333 Ann Johns 3.7 39 Bay st.  Comp352 Data structures 3 333 Ann Johns 3.7 39 Bay st.  Comp353 Databases 4 ID firstName lastName GPA Address 111 Joe Smith 4.0 45 Pine av. 222 Sue Brown 3.1 71 Main st. 333 Ann Johns 3.7 39 Bay st.  courseNumber name noOfCredits Comp352 Data structures 3 Comp353 Databases 4 48 Example Instance of Course: Instance of Student: SELECT ID, courseNumber  FROM Student, Course; ID firstName lastName GPA Address 111 Joe Smith 4.0 45 Pine av. 222 Sue Brown 3.1 71 Main st. 333 Ann Johns 3.7 39 Bay st.  courseNumber name noOfCredits Comp352 Data structures 3 Comp353 Databases 4 ID courseNumber 111 Comp352 111 Comp353 222 Comp352 222 Comp353 333 Comp352 333 Comp353 49 Example \xef\x81\xae Relation schemas: Student (ID, firstName, lastName, address, GPA) Ugrad (ID, major) \xef\x81\xae Query:  Find \xe2\x80\x9call\xe2\x80\x9d information about every undergraduate student \xef\x81\xae We try first by computing the Cartesian product (\xef\x82\xb4) SELECT \xef\x80\xaa FROM Student, Ugrad; 50 Example Instance of Ugrad: Instance of Student: SELECT \xef\x80\xaa FROM Student, Ugrad; ID firstName lastName GPA Address ID major 111 Joe Smith 4.0 45 Pine av. 111 CS 111 Joe Smith 4.0 45 Pine av. 333 EE 222 Sue Brown 3.1 71 Main st. 111 CS 222 Sue Brown 3.1 71 Main st. 333 EE 333 Ann Johns 3.7 39 Bay st.  111 CS 333 Ann Johns 3.7 39 Bay st.  333 EE ID firstName lastName GPA Address 111 Joe Smith 4.0 45 Pine av. 222 Sue Brown 3.1 71 Main st. 333 Ann Johns 3.7 39 Bay st.  ID major 111 CS 333 EE Only the green tuples should be in the query result. How to pick them only? 51 Example Instance of Ugrad: Instance of Student: SELECT \xef\x80\xaa  FROM Student, Ugrad  WHERE Student.ID = Ugrad.ID; ID firstName lastName GPA Address ID major 111 Joe Smith 4.0 45 Pine av. 111 CS 333 Ann Johns 3.7 39 Bay st.  333 EE ID firstName lastName GPA Address 111 Joe Smith 4.0 45 Pine av. 222 Sue Brown 3.1 71 Main st. 333 Ann Johns 3.7 39 Bay st.  ID major 111 CS 333 EE 52 Join in SQL \xef\x81\xae The above query is an example of Join operation \xef\x81\xae There are different kinds of joins, which we will studyl \xef\x81\xae To join relations R1,\xe2\x80\xa6,Rn in SQL:  \xef\x81\xae List all these relations in the FROM clause \xef\x81\xae Express the conditions in the WHERE clause in order to get the \xe2\x80\x9cdesired\xe2\x80\x9d  join 53 Joining Relations  \xef\x81\xae Relation schemas: Movie (title, year, length, filmType) Owns (title, year, studioName) \xef\x81\xae Query: Find title, length, and studio name of every movie  \xef\x81\xae Query in SQL: SELECT Movie.title, Movie.length, Owns.studioName  FROM Movie, Owns WHERE Movie.title = Owns.title AND Movie.year = Owns.year;  Question: Is Owns in Owns.studioName necessary?   54 Joining Relations  \xef\x81\xae Relation schemas: Movie (title, year, length, filmType) Owns (title, year, studioName) \xef\x81\xae Query:     Find the title and length of every movie produced by Disney studio. \xef\x81\xae Query in SQL: SELECT Movie.title, length FROM Movie, Owns WHERE Movie.title = Owns.title AND                Movie.year = Owns.year AND studioName = \xe2\x80\x99Disney\xe2\x80\x99;  55 Joining Relations  \xef\x81\xae Relation schemas: Movie (title, year, length, filmType) Owns (title, year, studioName)  StarsIn (title, year, starName) \xef\x81\xae Query: Find the title and length of Disney movies with JR as an actress.  \xef\x81\xae Query in SQL: SELECT Movie.title, Movie.length FROM Movie, Owns, StarsIn WHERE Movie.title = Owns.title AND Movie.year = Owns.year   AND Movie.title = StarsIn.title AND Movie.year = StarsIn.year AND studioName = \xe2\x80\x99Disney\xe2\x80\x99 AND starName = \xe2\x80\x98JR\xe2\x80\x99;  Example title year starName T1 1990 JR T2 1991 JR title year studioName T1 1990 Disney T2 1991 MGM title year length filmType T1 1990 124 color T2 1991 144 color SELECT Movie.title, Movie.length FROM Movie, Owns, StarsIn WHERE Movie.title = Owns.title AND Movie.year = Owns.year AND  Movie.title = StarsIn.title AND Movie.year = StarsIn.year AND studioName = \xe2\x80\x99Disney\xe2\x80\x99 AND starName = \xe2\x80\x99JR\xe2\x80\x99;  title length T1 124 Movie Owns StarsIn 57 Aggregation in SQL \xef\x81\xae SQL provides 5 operators that can be applied to a column of a relation in order to produce some kind of \xe2\x80\x9csummary\xe2\x80\x9d  \xef\x81\xae These operators are called aggregations \xef\x81\xae They are used in a SELECT clause and often applied to a scalar-valued attribute (column) or an expression in general. 58 Aggregation Operators \xef\x81\xae SUM \xef\x81\xae Returnes the sum of values in the column \xef\x81\xae AVG \xef\x81\xae Returns the average of values in the column \xef\x81\xae MIN \xef\x81\xae Returns the least value in the column \xef\x81\xae MAX \xef\x81\xae Returns the greatest value in the column \xef\x81\xae COUNT \xef\x81\xae Returns the number of values in the column, including the duplicates, unless the keyword DISTINCT is used explicitly 59 Example \xef\x81\xae Relation schema: Exec(name, address, cert#, netWorth) \xef\x81\xae Query: Find the average net worth of the movie executives \xef\x81\xae Query in SQL: SELECT AVG(netWorth) FROM Exec; \xef\x81\xae The sum of \xe2\x80\x9call\xe2\x80\x9d values in the column netWorth divided by the number of these values \xef\x81\xae In general, if a value v appears n times in the column, it contributes the value n*v to computing the average 60 Example \xef\x81\xae Relation schema: Exec (name, address, cert#, netWorth) \xef\x81\xae Query: How many movie executives are there in the Exec relation? \xef\x81\xae Query in SQL: SELECT COUNT(*) FROM Exec; \xef\x81\xae The use of * as a parameter is unique to COUNT;       Its use for other aggregation operations makes no sense. 61 Example \xef\x81\xae Relation schema: Exec (name, address,  cert#,  netWorth) \xef\x81\xae Query: How many different names are there in the Exec relation? \xef\x81\xae Query in SQL: SELECT COUNT (DISTINCT name) FROM Exec; \xef\x81\xae In query processing time, the system first eliminates the duplicates from the column name, and then counts the number of present values 62 Aggregation -- Grouping \xef\x81\xae To answer a query, we may need to \xe2\x80\x9cgroup\xe2\x80\x9cthe tuples according to the values of some other column(s) \xef\x81\xae Example: Suppose we want to find:      Total length in minutes of movies produced by each studio:        Movie(title, year, length, filmType, studioName, producerC#) \xef\x81\xae We must group the tuples in the Movie relation according to their studio, and then find the sum of the lengths within each group. The result displayed would look like: studio  SUM(length) Disney  12345 MGM  54321 \xe2\x80\xa6  \xe2\x80\xa6   63 Aggregation - Grouping \xef\x81\xae Relation schema: Movie(title, year, length, filmType, studioName, producerC#) \xef\x81\xae Query: What is the total length in minutes produced by each studio? \xef\x81\xae Query formulated/expressed in SQL: SELECT studioName, SUM(length) FROM Movie GROUP BY studioName; \xef\x81\xae Whatever aggregation used in the SELECT clause will be applied only within groups  \xef\x81\xae Only those attributes mentioned in the GROUP BY clause may appear unaggregated in the SELECT clause \xef\x81\xae Can we use GROUP BY without using aggregation? 64 Aggregation -- Grouping \xef\x81\xae Relation schema: Movie(title, year, length, filmType, studioName, producerC#) Exec(name, address, cert#, netWorth) \xef\x81\xae Query: For each producer (name), list the total length of the films produced \xef\x81\xae Query in SQL: SELECT Exec.name, SUM(Movie.length) FROM Exec, Movie WHERE Movie.producerC# = Exec.cert# GROUP BY Exec.name; 65 A rule about null values! \xef\x81\xae Nulls are counted when grouping but ignored when aggregating.     Example: Consider the instance below of R(A,B).      Which one of the following tuples will not be in the output?                                                                                       A    B     Select A, Sum(B)                                   null  1      From R                                                   2      1     Group By A;                                          null   null                                                                     3       2 A. (null, null)                                                      2        3 B. (2,4)                                                              1        null  C. (1,null)  D. (null,1)  66 A rule about null values! \xef\x81\xae The answer:                                                                                        A    B     Select A, Sum(B)                                   null  1      From R                                                   2      1     Group By A;                                          null   null                                                                     3       2 \xe2\x88\x9a  (null, null)                                                      2        3 \xef\x81\xae (2,4)                                                              1        null  \xef\x81\xae (1,null)  \xef\x81\xae  (null,1)  67 Another test! \xef\x81\xae Consider again the same instance of R(A,B) containing the tuples: (null,1), (2,1),  (null, null), (3,2), (2,3), and (1,null). Which of the following tuples will be in the result of the query below?      Select A, Sum(B)      From R      Where B<>2     Group By A;  A. (null, 0) B. (1,null)  C. (2,3)  D. (2,4)  68 Answer! \xef\x81\xae Consider an instance of R(A,B) with the tuples (null,1), (2,1),      (null, null), (3,2), (2,3), and (1,null). Which one of the following tuples will be present in the result of the query below?     Select A, Sum(B)      From R      Where B<>2     Group By A;  \xef\x81\xae (null, 0)                                                              null  1 \xef\x81\xae (1,null)                                                                2     1 \xef\x81\xae (2,3)                                                                    2     3  \xe2\x88\x9a   (2,4) 69 Aggregation \xe2\x80\x93 HAVING clause \xef\x81\xae We might be interested in not every group but those which satisfy certain conditions  \xef\x81\xae For this, after a GROUP BY clause use a HAVING clause  \xef\x81\xae HAVING is followed by some conditions about the group \xef\x81\xae We can not use a HAVING clause without GROUP BY 70 Aggregation \xe2\x80\x93 HAVING clause \xef\x81\xae Relation schema: Movie (title, year, length, filmType, studioName, producerC#) Exec(name, address, cert#, netWorth) \xef\x81\xae Query: For those producers who made at least one film prior to 1930, list the  total length of the films produced \xef\x81\xae Query in SQL: SELECT Exec.name, SUM(Movie.length) FROM Exec, Movie WHERE producerC# = cert# GROUP BY Exec.name HAVING MIN(Movie.year) \xef\x80\xbc 1930; 71 Aggregation \xe2\x80\x93 HAVING clause \xef\x81\xae This query chooses the group based on the property of each group SELECT Exec.name, SUM(Movie.length) FROM Exec, Movie WHERE producerC# = cert# GROUP BY Exec.name HAVING MIN(Movie.year) < 1930;  \xef\x81\xae Consider the following query which chooses the movies based on the property of  each movie tuple:  SELECT Exec.name, SUM(Movie.length) FROM Exec, Movie WHERE producerC# = cert# AND Movie.year < 1930 GROUP BY Exec.name;   72 Order By \xef\x81\xae The SQL statements/queries we looked at so far return an unordered relation/bag. What if we want the result displayed in a certain order? Movie (title, year, length, filmType, studioName, producerC#)  SELECT Exec.name, SUM(Movie.length) FROM Exec, Movie WHERE producerC# = cert# GROUP BY Exec.name HAVING MIN(Movie.year) < 1930 ORDER BY Exec.name ASC;  In general: ORDER BY A ASC, B DESC, C ASC;  73 Database Modifications \xef\x81\xae SQL & Database Modifications? \xef\x81\xae We now look at SQL statements that do not return tuples,      but rather change the state (content) of the database \xef\x81\xae There are three types of such statements/transactions: \xef\x81\xae Insert tuples into a relation \xef\x81\xae Delete certain tuples  from a relation \xef\x81\xae Update values of certain attributes of certain existing tuples     These types of operations that modify the database content are referred  to as transactions 74 Insertion \xef\x81\xae The insertion statement consists of: \xef\x81\xae The keyword INSERT INTO \xef\x81\xae The name of a relation R \xef\x81\xae A parenthesized list of attributes of the relation R \xef\x81\xae The keyword VALUES  \xef\x81\xae A tuple expression, that is, a parenthesized list of concrete values, one for each attribute in the attribute list  \xef\x81\xae The form of an insert statement:  INSERT INTO R(A1, \xe2\x80\xa6, An) VALUES (v1,\xe2\x80\xa6, vn) ; \xe2\x80\xa2 This command inserts the tuple (v1,...,vn) to table R, where vi  is the value of attribute Ai , for  i = 1,\xe2\x80\xa6,n  75 Insertion \xef\x81\xae Relation schema: StarsIn (title, year, starName) \xef\x81\xae Update the database: Add \xe2\x80\x9cSydney Greenstreet\xe2\x80\x9d to the list of stars of The Maltese Falcon \xef\x81\xae In SQL:  INSERT INTO StarsIn (title,year, starName)  VALUES(\xe2\x80\x99The Maltese Falcon\xe2\x80\x99, 1942, \xe2\x80\x99Sydney Greenstreet\xe2\x80\x99);      Another formulation of this query:      INSERT INTO StarsIn   VALUES(\xe2\x80\x99The Maltese Falcon\xe2\x80\x99, 1942, \xe2\x80\x99Sydney Greenstreet\xe2\x80\x99);  76 Insertion \xef\x81\xae The previous insertion statement was \xe2\x80\x9csimple\xe2\x80\x9d in that it       added one tuple only into a relation \xef\x81\xae Instead of using explicit values for a tuple in insertion, we can request  a set of tuples to be inserted. For this we define, in a subquery,  the set of tuples from an existing relation \xef\x81\xae This subquery replaces the keyword VALUES and the tuple expression in the INSERT statement 77 Insertion \xef\x81\xae Database schema: Studio(name, address, presC#) Movie(title, year, length, filmType, studioName, producerC#) \xef\x81\xae Update the database:     Add to Studio, all studio names mentioned in the Movie relation \xef\x81\xae Note: If the list of attributes in an \xe2\x80\x9cinsert\xe2\x80\x9d statement does not include all the attributes of the relation, the tuple created will have the default value for each missing attribute \xef\x81\xae Since there is no way to determine an address or a presC# for a studio tuple, NULL will be used for these attributes. 78 Insertion \xef\x81\xae Database schema: Studio(name, address, presC#) Movie(title, year, length, filmType, studioName, producerC#) \xef\x81\xae Update the database: Add to Studio, all studio names mentioned in the Movie relation \xef\x81\xae In SQL:  INSERT INTO Studio(name)  SELECT DISTINCT studioName  FROM Movie  WHERE studioName NOT IN (SELECT name        FROM Studio);  79 Deletion \xef\x81\xae A delete statement consists of : \xef\x81\xae The keyword DELETE FROM \xef\x81\xae The name of a relation R \xef\x81\xae The keyword WHERE \xef\x81\xae A condition  \xef\x81\xae The syntax of the delete statement:  DELETE FROM R WHERE \xef\x80\xbccondition\xef\x80\xbe; \xef\x81\xae The effect of executing this statement is that \xe2\x80\x9cevery tuple\xe2\x80\x9d in relation R satisfying the condition will be deleted from R \xef\x81\xae Note: unlike the INSERT, we MAY need a WHERE clause here 80 Deletion \xef\x81\xae Relation schema: StarsIn(title, year, starName) \xef\x81\xae Update: Delete the tuple that says:       Sydney Greenstreet was a star in The Maltese Falcon \xef\x81\xae In SQL:  DELETE FROM StarIn  WHERE title = \xe2\x80\x99The Maltese Falcon\xe2\x80\x99 AND                     starName = \xe2\x80\x99Sydney Greenstreet\xe2\x80\x99; 81 Deletion \xef\x81\xae Relation schema: Exec(name, address, cert#, netWorth) \xef\x81\xae Update: Delete every movie executive whose net worth is < $10,000,000 \xef\x81\xae In SQL:  DELETE FROM Exec  WHERE netWorth < 10,000,000;      Anything wrong here?! 82 Deletion \xef\x81\xae Relation schema: Studio(name, address, presC#) Movie(title, year, length, filmType, studioName, producerC#) \xef\x81\xae Update: Delete from Studio, those studios not mentioned in Movie      (i.e., we don\xe2\x80\x99t want to have non-productive studios!!)  \xef\x81\xae In SQL:  DELETE FROM Studio  WHERE name NOT IN (SELECT StudioName          FROM Movie);  83 Update \xef\x81\xae Update statement consists of: \xef\x81\xae The keyword UPDATE \xef\x81\xae The name of a relation R \xef\x81\xae The keyword SET \xef\x81\xae A list of formulas, each of which will assign a value to an attribute of R \xef\x81\xae The keyword WHERE \xef\x81\xae A condition \xef\x81\xae The syntax of the update statement:  UPDATE  R  SET \xef\x80\xbcnew-value assignments\xef\x80\xbe WHERE \xef\x80\xbccondition\xef\x80\xbe; 84 Update \xef\x81\xae Database schema: Studio(name, address, presC#) Exec(name, address, cert#, netWorth) \xef\x81\xae Update:      Modify table Exec by attaching the title \xe2\x80\x98Pres. \xe2\x80\x99 in front of  the name of every movie executive who is also the president of some studio \xef\x81\xae In SQL:  UPDATE Exec  SET name = \xe2\x80\x99Pres. \xe2\x80\x99 || name             \xef\x82\xac this line performs the update  WHERE cert# IN (SELECT presC#      FROM Studio); 85 Defining Database Schema \xef\x81\xae SQL includes two types of statements: \xef\x81\xae DML \xef\x81\xae DDL  \xef\x81\xae So far we looked at the DML part to specify or modify the relation/database instances. \xef\x81\xae The DDL part allows us to define or modify the relation/database schemas.     86 Defining Database Schema \xef\x81\xae To create a table in SQL: \xef\x81\xae CREATE TABLE name (list of elements);  \xe2\x80\xa2 Principal elements are attributes and their types,      but declarations of key and constraints may also appear \xef\x81\xae Example: CREATE TABLE Star (         name CHAR(30),          address VARCHAR(255),          gender CHAR(1),         birthdate DATE  ); 87 Defining Database Schema \xef\x81\xae To delete a table from the database: \xef\x81\xae DROP TABLE name; \xef\x81\xae Example: DROP TABLE Star; 88 Data types \xef\x81\xae INT or INTEGER  \xef\x81\xae REAL or FLOAT \xef\x81\xae DECIMAL(n, d)  -- NUMERIC(n, d) \xef\x81\xae DECIMAL(6, 2), e.g., 0123.45 \xef\x81\xae CHAR(n)/BIT(B) fixed length character/bit string \xef\x81\xae Unused part is padded with  the "pad character\xe2\x80\x9d, denoted as \xef\x81\x9e  \xef\x81\xae VARCHAR(n) / BIT VARYING(n) variable-length strings up to n characters \xef\x81\xae Oracle also uses VARCHAR2(n), which is truly varying length;      Since VARCHAR uses fixed array with end-marker, it is not followed any longer in Oracle. 89 Data types (cont\xe2\x80\x99d) \xef\x81\xae SQL2 Syntax for: -- Time: \'hh:mm:ss[.ss...]\' -- Date:  \xe2\x80\x99yyyy-mm-dd\xe2\x80\x99     (m =0 or 1) \xef\x81\xae Example: CREATE TABLE Days(d DATE); INSERT INTO Days VALUES(\xe2\x80\x992012-12-23\xe2\x80\x99);  \xef\x81\xb6  Note 1: In Oracle, the default format of date is \xe2\x80\x99dd-mon-yy\xe2\x80\x99, e.g.,    INSERT INTO Days VALUES(\xe2\x80\x9922-jan-18\xe2\x80\x99);  \xef\x81\xb6 Note 2: The Oracle function to_date converts a specified format into default, e.g.,     INSERT INTO Days VALUES (to_date(\'2018-01-22\', \'yyyy-mm-dd\')); 90 Altering Relation Schemas \xef\x81\xae Adding Columns  \xef\x81\xae Add an attribute to an existing relation R:     ALTER TABLE  R  ADD \xef\x80\xbccolumn declaration\xef\x80\xbe; \xef\x81\xae Example: Add attribute phone to table Star \xef\x81\xae ALTER TABLE Star ADD phone CHAR(16); \xef\x81\xae Removing Columns  \xef\x81\xae Remove an attribute from a relation R using DROP:  \xef\x81\xae ALTER TABLE  R  DROP COLUMN \xef\x80\xbccolumn_name\xef\x80\xbe; \xef\x81\xae Example: Remove column phone from Star \xef\x81\xae ALTER TABLE Star DROP COLUMN phone; Note: Can\xe2\x80\x99t drop a column, if it is the only column 91 Attribute Properties \xef\x81\xae We can assert that the value of an attribute A to be: \xef\x81\xae NOT NULL \xe2\x80\xa2 Then every tuple must have a \xe2\x80\x9creal\xe2\x80\x9d value (not null) for this attribute  \xef\x81\xae DEFAULT value \xe2\x80\xa2 Null is the default value for every attribute \xe2\x80\xa2 However, we can consider/define any value we wish as the default for a column, when we create a table. 92 Attribute Properties CREATE TABLE Star (         name CHAR(30),          address VARCHAR(255),          gender CHAR(1) DEFAULT \xe2\x80\x99?\xe2\x80\x99,         birthdate DATE NOT NULL); \xef\x81\xae Example: Add an attribute with a default value: \xef\x81\xae ALTER TABLE Star ADD phone CHAR(16) DEFAULT \xe2\x80\x99unlisted\xe2\x80\x99; \xef\x81\xae INSERT INTO Star(name, birthdate) VALUES (\xe2\x80\x99Sally\xe2\x80\x99 ,\xe2\x80\x990000-00-00\xe2\x80\x99) name address   gender     birthdate   phone   Sally   NULL   ?     0000-00-00   unlisted \xef\x81\xae INSERT INTO Star(name, phone) VALUES (\xe2\x80\x99Sally\xe2\x80\x99, \xe2\x80\x99333-2255\xe2\x80\x99); \xef\x81\xae this insertion op. fails since the value for birthdate is not given,  since Null was disallowed by the user. 93 Attribute Properties To add default value after an attribute is defined: \xef\x81\xae ALTER TABLE Star ALTER phone SET DEFAULT \xe2\x80\x98no-phone\xe2\x80\x99; \xef\x81\xae In Oracle:       ALTER TABLE Star MODIFY phone DEFAULT \xe2\x80\x98no-phone\xe2\x80\x99;  94'