b'\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMicrosoft PowerPoint - DB6.ppt [Compatibility Mode]\n\n\n3/3/2020\n\n1\n\nNormal Forms\n\n\xef\xbf\xbd If a relation schema is in a normal forms, we know that it is \n\nin some particular shape/health in the sense that certain \nkinds of problems and issues (related to redundancy) will not arise\n\n\xef\xbf\xbd Given a relation schema R, we need to determine if it is in \ncertain normal form. If it is not, we need methods to \n\ndecompose it into smaller such normal relations. How?\n\n\xef\xbf\xbd To address these issues, we study normal forms\n\n1\n\n1NF2NF3NFBCNF\n\nNormal Forms\n\n\xef\xbf\xbd The normal forms as defined and captured by FD\xe2\x80\x99s:\n\xef\xbf\xbd First normal form (1NF)\n\n\xef\xbf\xbd Second normal form (2NF)\n\n\xe2\x88\x9a  Third normal form (3NF)\n\xe2\x88\x9a  Boyce-Codd normal form (BCNF)\n\n\xef\xbf\xbd The relationships among these normal forms:\n\n2\n\nThird Normal Form (3NF)\nLet R be a relation schema with a set of FD\xe2\x80\x99s F.\n\n\xef\xbf\xbd We say R w.r.t. F is in 3NF (third normal form), if for every \nFD X \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 A in F, at least one of the following conditions holds:\n\xef\xbf\xbd X \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 A is a trivial, i.e., A \xe2\x88\x88\xe2\x88\x88\xe2\x88\x88\xe2\x88\x88 X, or \n\xef\xbf\xbd X is a superkey, or\n\xef\xbf\xbd X is not a key but A is part of some key of R\n\n\xef\xbf\xbd Therefore, to determine if R is in 3NF w.r.t. F, we need to:\n\xef\xbf\xbd Check if the LHS of each nontrivial FD in F is a superkey\n\xef\xbf\xbd If not, check if its RHS is part of any key of R\n\n3\n\nBoyce-Codd Normal Form\n\nGiven: A relation schema R with a set of FD\xe2\x80\x99s F on R.\n\n\xef\xbf\xbd We say R w.r.t. F is in Boyce-Codd normal form, if for every \nFD X \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 A in F, at least one of the following conditions holds:\n\xef\xbf\xbd A \xe2\x88\x88\xe2\x88\x88\xe2\x88\x88\xe2\x88\x88 X, that is, X \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 A is a trivial FD, or\n\n\xef\xbf\xbd X is a superkey\n\n\xef\xbf\xbd To determine if R is in BCNF w.r.t. F, \n\nFor every FD X \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 A, check if its LHS X is a superkey.\n\nFor any FD X \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 A in F, if there is an attribute B of R that is not in X+, \nthen R is not in BCNF. \n\n4\n\nDecomposition into BCNF\n\n\xef\xbf\xbd Consider <R, F>, where R is in 1NF.\n\n\xef\xbf\xbd If R is not in BCNF, we can always obtain a lossless-join\ndecomposition of R into a collection of BCNF relations\n\n\xef\xbf\xbd However, this decomposition may not always be dependency \n\npreserving.\n\n\xef\xbf\xbd The basic step of a BCNF algorithm (done recursively):\n\nPick every FD X \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 A \xe2\x88\x88\xe2\x88\x88\xe2\x88\x88\xe2\x88\x88 F that violates the BCNF requirement: \n\n1. Decompose R into two relations: XA and R \xe2\x80\x93 A\n\n2. If either R\xe2\x80\x93A or XA is not in BCNF, decompose it further\n\n5\n\nExample (Decomposition into BCNF relations)\n\nR = ABCDE\nF = { A \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 B, C \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 D }\n\nA \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 B\n\nR1 = AB\nF1 = { A \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 B }\n\nR2 = ACDE\nF2 = { C \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 D }\n\nR21 = CD\nF21 = { C \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 D }\n\nR22 = ACE\nF22 = { }\n\nC \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 D\n\n6\n\n\n\n3/3/2020\n\n2\n\nDecomposition into 3NF\n\xef\xbf\xbd We can always obtain a lossless-join, dependency-preserving \n\ndecomposition of a relation into 3NF relations. How?\n\n\xef\xbf\xbd We discuss 2 solution approaches for 3NF decomposition.\n\xef\xbf\xbd Approach 1: using the binary decomposition method. \n\nLet R = { R1, R2, . . . Rn} be the result. Recall that this is always \nlossless-join, but may not preserve all the FD\xe2\x80\x99s\xef\xbf\xbd\xef\xbf\xbd\xef\xbf\xbd\xef\xbf\xbd need to fix this!\n\xef\xbf\xbd Identify the set N of FD\xe2\x80\x99s in F which we lost  in the decomposition proc.\n\xef\xbf\xbd For each FD X \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 A in N, create a relation schema XA and add it to R\n\xef\xbf\xbd A refinement step to avoid creating MANY relations:  if there are several FD\xe2\x80\x99s \n\nwith the same LHS, e.g., X \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 A1, X \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 A2, . . . , X \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 Ak, create just one \nrelation with schema XA1\xe2\x80\xa6Ak\n\n7\n\nExample (3NF Decomposition)\nR = ABCDE\n\nF = { BD \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 E, C \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 B , CE \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 A }\n\nBD \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 E\n\nR1 = BDE\nF1 = { BD \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 E }\n\nR2 = ABCD\nF2 = {C \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 B , CD \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 A }\n\nR21 = CB\nF21 = { C \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 B }\n\nR22 = ACD\nF22 = { CD \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 A }\n\nC \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 B\n\n\xef\xbf\xbd CE \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 A is not preserved, since A \xe2\x88\x89\xe2\x88\x89\xe2\x88\x89\xe2\x88\x89 {CE}+  w.r.t. F1 \xe2\x8b\x83\xe2\x8b\x83\xe2\x8b\x83\xe2\x8b\x83 F21 \xe2\x8b\x83\xe2\x8b\x83\xe2\x8b\x83\xe2\x8b\x83 F22\n\xef\xbf\xbd To fix this, We add to R, a new relation R3 = CEA with F3 = {CE \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 A } \n\n8\n\nExample (using a different order)\nR = ABCDE\n\nF = { BD \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 E, C \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 B , CE \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 A }\n\nCE \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 A\n\nR1 = CEA\nF1 = { CE \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 A }\n\nR2 = BCED\nF2 = { C \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 B , BD \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 E }\n\nR21 = BDE\nF21 = { BD \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 E }\n\nR22 = BCD\nF22 = { C \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 B }\n\nBD \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 E\n\n\xef\xbf\xbd This 3NF decomposition is\n\ndependency preserving,\n\nand of course lossless-join \n\nR221 = BC\nF221 = { C \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 B }\n\nR222 = CD\nF222 = \xe2\x88\x85\xe2\x88\x85\xe2\x88\x85\xe2\x88\x85\n\nC \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 B\n\n9\n\nDecomposition into 3NF\n\n\xef\xbf\xbd 1ST approach (binary decomposition):\n\n\xef\xbf\xbd Lossless-join \xe2\x88\x9a\n\xef\xbf\xbd May not be dependency preserving. If so, then add \nextra relations XA, for every FD X \xe2\x86\x92 A we lost\n\n\xef\xbf\xbd Approach 2: the synthesis approcah\n\xef\xbf\xbd Dependency preservation \xe2\x88\x9a\n\xef\xbf\xbd However, may not be lossless-join. If so, we must add \nto R, one extra relation that includes whose attributes \nform a key of R\nWhat would be the FDs on this newly added relation?\n\n10\n\nDecomposition into 3NF \n(Using the synthesis approach)\n\nConsider <R, F> \n\n\xef\xbf\xbd The synthesis approach:\n\n\xef\xbf\xbd Get a minimal cover Fc of F\n\n\xef\xbf\xbd For each FD X \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 A in Fc, add schema XA to R\n\n\xef\xbf\xbd If the decomposition R is not lossless, \n\nadd to R an extra relation containing any key of R\n\n11\n\nExample\n\xef\xbf\xbd R = ( A, B, C )\n\n\xef\xbf\xbd F = { A \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 B, C \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 B }\n\xef\xbf\xbd Decompose R into R1 = ( A, B ) and R2 = ( B, C ) \n\n\xef\xbf\xbd This decomposition is not lossless\n\n\xef\xbf\xbd Add R3 = ( A, C )\n\n\xef\xbf\xbd The decomposition R = {R1, R2, R3} is both \nlossless and dependency-preserving\n\n12\n\n\n\n3/3/2020\n\n3\n\nAn Algorithm to Check Lossless join\nSuppose relation R{A1 , . . . , Ak} is decomposed into R1,. . . , Rn\nTo determine if this decomposition is lossless, we use a table,\n\nL[ 1 \xe2\x80\xa6 n ] [ 1 . . . k ] \n\nInitializing the table:\n\nfor each relation Ri do\nfor each attribute Aj do\n\nif Aj is an attribute in Ri\nthen L [ i ][ j ] \xe2\x86\x90\xe2\x86\x90\xe2\x86\x90\xe2\x86\x90 aj\nelse L [ i ][ j ] \xe2\x86\x90\xe2\x86\x90\xe2\x86\x90\xe2\x86\x90 bij\n\n13\n\nAlgorithm to Check Lossless (cont\xe2\x80\x99d)\nrepeat \n\nfor each FD X \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 Y in F do:\nif \xe2\x88\x83\xe2\x88\x83\xe2\x88\x83\xe2\x88\x83 rows i and j such that L [ i ] == L [ j ], for each attribute in X,\n\nthen for \xe2\x88\x80\xe2\x88\x80\xe2\x88\x80\xe2\x88\x80 column t corresponding to an attribute At in Y do:\nif L [ i ][ t ] == at\n\nthen L [ j ][ t ] \xe2\x86\x90\xe2\x86\x90\xe2\x86\x90\xe2\x86\x90 at\nelse if L [ j ][ t ] == at\n\nthen L [ i ][ t ] \xe2\x86\x90\xe2\x86\x90\xe2\x86\x90\xe2\x86\x90 at\nelse L [ j ][ t ] \xe2\x86\x90\xe2\x86\x90\xe2\x86\x90\xe2\x86\x90 L [ i ][ t ]\n\nuntil no change\n\nThe decomposition is lossless if, after performing this algorithm, L contains a\n\nrow of all a\xe2\x80\x99s. That is, if there exists a row i in L such that: L [ i ][ j ] == aj\nfor every column j corresponding to each attribute Aj in R\n\n14\n\nExamples\n\xef\xbf\xbd Given \xe2\x89\xba\xe2\x89\xba\xe2\x89\xba\xe2\x89\xbaR,F\xe2\x89\xbb\xe2\x89\xbb\xe2\x89\xbb\xe2\x89\xbb, where R = ( A, B, C, D ), and \n\nF = { A \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 B, A \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 C, C \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 D } is a set of FD\xe2\x80\x99s on R\n\n\xef\xbf\xbd Is the decomposition R = {R1, R2} lossless, where \n\nR1 = ( A, B, C ) and R2 = ( C , D)?\n\xef\xbf\xbd To be discussed in class\n\n\xef\xbf\xbd Now consider S = ( A, B, C, D, E ) with the FD\xe2\x80\x99s:\n\nG = { AB \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 CD,  A \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 E, C \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 D }\n\n\xef\xbf\xbd Is decomposition of S = {S1, S2, S3} lossless, where \n\nS1 = ( A, B, C ), S2 = ( B, C, D ), and S3 = ( C, D, E )?\n\xef\xbf\xbd To be discussed in class 15\n\nChecking if a decomposition is \nDependency-Preserving?\n\nInputs: Let  \xe2\x89\xba\xe2\x89\xba\xe2\x89\xba\xe2\x89\xbaR,F\xe2\x89\xbb\xe2\x89\xbb\xe2\x89\xbb\xe2\x89\xbb, where F = {X1 \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 Y1,\xe2\x80\xa6, Xn \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 Yn}.\nSuppose R = { R1,\xe2\x80\xa6,Rk } is a decomposition of R\nand Fi is the projection of F on schema Ri\n\nMethod:\n\npreserved \xe2\x86\x90\xe2\x86\x90\xe2\x86\x90\xe2\x86\x90 TRUE \n\nfor each FD X \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 Y in F and while preserved == TRUE\ndo compute X+ under F1 \xe2\x88\xaa\xe2\x88\xaa\xe2\x88\xaa\xe2\x88\xaa . . . \xe2\x88\xaa\xe2\x88\xaa\xe2\x88\xaa\xe2\x88\xaa Fk ;\n\nif Y \xe2\x8a\x88 X+ then {preserved \xe2\x86\x90\xe2\x86\x90\xe2\x86\x90\xe2\x86\x90 FALSE;  exit };\nend\n\n16\n\nExample\n\xef\xbf\xbd Consider R = ( A, B, C, D ), F = { A \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 B, B \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 C, C \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 D }\n\n\xef\xbf\xbd Is the decomposition R = {R1, R2} dependency-preserving, where\n\nR1 = ( A, B ), F1 = { A \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 B }, R2 = ( A, C , D), AND F2 = { C \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 D, A \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 D, A \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 C }?\n\n\xef\xbf\xbd Check if A \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 B is preserved\n\xe2\x80\xa2 Compute A+ under { A \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 B } \xe2\x88\xaa\xe2\x88\xaa\xe2\x88\xaa\xe2\x88\xaa { C \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 D, A \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 D, A \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 C }\n\n\xe2\x80\xa2 A+ = { A, B, C, D}\n\xe2\x80\xa2 Check if B \xe2\x88\x88\xe2\x88\x88\xe2\x88\x88\xe2\x88\x88 A+\n\xe2\x80\xa2 Yes\n\n\xe2\x80\xa2 A \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92B is preserved\n\xef\xbf\xbd Check if B \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 C is preserved\n\n\xe2\x80\xa2 Compute B+ under { A \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 B } \xe2\x88\xaa\xe2\x88\xaa\xe2\x88\xaa\xe2\x88\xaa { C \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 D, A \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 D, A \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 C }\n\xe2\x80\xa2 B+ = { B } \n\n\xe2\x80\xa2 Check if C \xe2\x88\x88\xe2\x88\x88\xe2\x88\x88\xe2\x88\x88 B+\n\xe2\x80\xa2 No\n\n\xe2\x80\xa2 B \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 C is not preserved\n\n\xef\xbf\xbdThe decomposition is not dependency-preserving 17\n\n\n'