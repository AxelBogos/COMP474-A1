b'Microsoft PowerPoint - DB6.ppt [Compatibility Mode]3/3/20201Normal Forms\xef\xbf\xbd If a relation schema is in a normal forms, we know that it is in some particular shape/health in the sense that certain kinds of problems and issues (related to redundancy) will not arise\xef\xbf\xbd Given a relation schema R, we need to determine if it is in certain normal form. If it is not, we need methods to decompose it into smaller such normal relations. How?\xef\xbf\xbd To address these issues, we study normal forms11NF2NF3NFBCNFNormal Forms\xef\xbf\xbd The normal forms as defined and captured by FD\xe2\x80\x99s:\xef\xbf\xbd First normal form (1NF)\xef\xbf\xbd Second normal form (2NF)\xe2\x88\x9a  Third normal form (3NF)\xe2\x88\x9a  Boyce-Codd normal form (BCNF)\xef\xbf\xbd The relationships among these normal forms:2Third Normal Form (3NF)Let R be a relation schema with a set of FD\xe2\x80\x99s F.\xef\xbf\xbd We say R w.r.t. F is in 3NF (third normal form), if for every FD X \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 A in F, at least one of the following conditions holds:\xef\xbf\xbd X \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 A is a trivial, i.e., A \xe2\x88\x88\xe2\x88\x88\xe2\x88\x88\xe2\x88\x88 X, or \xef\xbf\xbd X is a superkey, or\xef\xbf\xbd X is not a key but A is part of some key of R\xef\xbf\xbd Therefore, to determine if R is in 3NF w.r.t. F, we need to:\xef\xbf\xbd Check if the LHS of each nontrivial FD in F is a superkey\xef\xbf\xbd If not, check if its RHS is part of any key of R3Boyce-Codd Normal FormGiven: A relation schema R with a set of FD\xe2\x80\x99s F on R.\xef\xbf\xbd We say R w.r.t. F is in Boyce-Codd normal form, if for every FD X \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 A in F, at least one of the following conditions holds:\xef\xbf\xbd A \xe2\x88\x88\xe2\x88\x88\xe2\x88\x88\xe2\x88\x88 X, that is, X \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 A is a trivial FD, or\xef\xbf\xbd X is a superkey\xef\xbf\xbd To determine if R is in BCNF w.r.t. F, For every FD X \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 A, check if its LHS X is a superkey.For any FD X \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 A in F, if there is an attribute B of R that is not in X+, then R is not in BCNF. 4Decomposition into BCNF\xef\xbf\xbd Consider <R, F>, where R is in 1NF.\xef\xbf\xbd If R is not in BCNF, we can always obtain a lossless-joindecomposition of R into a collection of BCNF relations\xef\xbf\xbd However, this decomposition may not always be dependency preserving.\xef\xbf\xbd The basic step of a BCNF algorithm (done recursively):Pick every FD X \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 A \xe2\x88\x88\xe2\x88\x88\xe2\x88\x88\xe2\x88\x88 F that violates the BCNF requirement: 1. Decompose R into two relations: XA and R \xe2\x80\x93 A2. If either R\xe2\x80\x93A or XA is not in BCNF, decompose it further5Example (Decomposition into BCNF relations)R = ABCDEF = { A \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 B, C \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 D }A \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 BR1 = ABF1 = { A \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 B }R2 = ACDEF2 = { C \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 D }R21 = CDF21 = { C \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 D }R22 = ACEF22 = { }C \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 D63/3/20202Decomposition into 3NF\xef\xbf\xbd We can always obtain a lossless-join, dependency-preserving decomposition of a relation into 3NF relations. How?\xef\xbf\xbd We discuss 2 solution approaches for 3NF decomposition.\xef\xbf\xbd Approach 1: using the binary decomposition method. Let R = { R1, R2, . . . Rn} be the result. Recall that this is always lossless-join, but may not preserve all the FD\xe2\x80\x99s\xef\xbf\xbd\xef\xbf\xbd\xef\xbf\xbd\xef\xbf\xbd need to fix this!\xef\xbf\xbd Identify the set N of FD\xe2\x80\x99s in F which we lost  in the decomposition proc.\xef\xbf\xbd For each FD X \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 A in N, create a relation schema XA and add it to R\xef\xbf\xbd A refinement step to avoid creating MANY relations:  if there are several FD\xe2\x80\x99s with the same LHS, e.g., X \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 A1, X \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 A2, . . . , X \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 Ak, create just one relation with schema XA1\xe2\x80\xa6Ak7Example (3NF Decomposition)R = ABCDEF = { BD \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 E, C \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 B , CE \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 A }BD \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 ER1 = BDEF1 = { BD \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 E }R2 = ABCDF2 = {C \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 B , CD \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 A }R21 = CBF21 = { C \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 B }R22 = ACDF22 = { CD \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 A }C \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 B\xef\xbf\xbd CE \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 A is not preserved, since A \xe2\x88\x89\xe2\x88\x89\xe2\x88\x89\xe2\x88\x89 {CE}+  w.r.t. F1 \xe2\x8b\x83\xe2\x8b\x83\xe2\x8b\x83\xe2\x8b\x83 F21 \xe2\x8b\x83\xe2\x8b\x83\xe2\x8b\x83\xe2\x8b\x83 F22\xef\xbf\xbd To fix this, We add to R, a new relation R3 = CEA with F3 = {CE \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 A } 8Example (using a different order)R = ABCDEF = { BD \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 E, C \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 B , CE \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 A }CE \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 AR1 = CEAF1 = { CE \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 A }R2 = BCEDF2 = { C \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 B , BD \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 E }R21 = BDEF21 = { BD \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 E }R22 = BCDF22 = { C \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 B }BD \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 E\xef\xbf\xbd This 3NF decomposition isdependency preserving,and of course lossless-join R221 = BCF221 = { C \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 B }R222 = CDF222 = \xe2\x88\x85\xe2\x88\x85\xe2\x88\x85\xe2\x88\x85C \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 B9Decomposition into 3NF\xef\xbf\xbd 1ST approach (binary decomposition):\xef\xbf\xbd Lossless-join \xe2\x88\x9a\xef\xbf\xbd May not be dependency preserving. If so, then add extra relations XA, for every FD X \xe2\x86\x92 A we lost\xef\xbf\xbd Approach 2: the synthesis approcah\xef\xbf\xbd Dependency preservation \xe2\x88\x9a\xef\xbf\xbd However, may not be lossless-join. If so, we must add to R, one extra relation that includes whose attributes form a key of RWhat would be the FDs on this newly added relation?10Decomposition into 3NF (Using the synthesis approach)Consider <R, F> \xef\xbf\xbd The synthesis approach:\xef\xbf\xbd Get a minimal cover Fc of F\xef\xbf\xbd For each FD X \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 A in Fc, add schema XA to R\xef\xbf\xbd If the decomposition R is not lossless, add to R an extra relation containing any key of R11Example\xef\xbf\xbd R = ( A, B, C )\xef\xbf\xbd F = { A \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 B, C \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 B }\xef\xbf\xbd Decompose R into R1 = ( A, B ) and R2 = ( B, C ) \xef\xbf\xbd This decomposition is not lossless\xef\xbf\xbd Add R3 = ( A, C )\xef\xbf\xbd The decomposition R = {R1, R2, R3} is both lossless and dependency-preserving123/3/20203An Algorithm to Check Lossless joinSuppose relation R{A1 , . . . , Ak} is decomposed into R1,. . . , RnTo determine if this decomposition is lossless, we use a table,L[ 1 \xe2\x80\xa6 n ] [ 1 . . . k ] Initializing the table:for each relation Ri dofor each attribute Aj doif Aj is an attribute in Rithen L [ i ][ j ] \xe2\x86\x90\xe2\x86\x90\xe2\x86\x90\xe2\x86\x90 ajelse L [ i ][ j ] \xe2\x86\x90\xe2\x86\x90\xe2\x86\x90\xe2\x86\x90 bij13Algorithm to Check Lossless (cont\xe2\x80\x99d)repeat for each FD X \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 Y in F do:if \xe2\x88\x83\xe2\x88\x83\xe2\x88\x83\xe2\x88\x83 rows i and j such that L [ i ] == L [ j ], for each attribute in X,then for \xe2\x88\x80\xe2\x88\x80\xe2\x88\x80\xe2\x88\x80 column t corresponding to an attribute At in Y do:if L [ i ][ t ] == atthen L [ j ][ t ] \xe2\x86\x90\xe2\x86\x90\xe2\x86\x90\xe2\x86\x90 atelse if L [ j ][ t ] == atthen L [ i ][ t ] \xe2\x86\x90\xe2\x86\x90\xe2\x86\x90\xe2\x86\x90 atelse L [ j ][ t ] \xe2\x86\x90\xe2\x86\x90\xe2\x86\x90\xe2\x86\x90 L [ i ][ t ]until no changeThe decomposition is lossless if, after performing this algorithm, L contains arow of all a\xe2\x80\x99s. That is, if there exists a row i in L such that: L [ i ][ j ] == ajfor every column j corresponding to each attribute Aj in R14Examples\xef\xbf\xbd Given \xe2\x89\xba\xe2\x89\xba\xe2\x89\xba\xe2\x89\xbaR,F\xe2\x89\xbb\xe2\x89\xbb\xe2\x89\xbb\xe2\x89\xbb, where R = ( A, B, C, D ), and F = { A \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 B, A \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 C, C \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 D } is a set of FD\xe2\x80\x99s on R\xef\xbf\xbd Is the decomposition R = {R1, R2} lossless, where R1 = ( A, B, C ) and R2 = ( C , D)?\xef\xbf\xbd To be discussed in class\xef\xbf\xbd Now consider S = ( A, B, C, D, E ) with the FD\xe2\x80\x99s:G = { AB \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 CD,  A \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 E, C \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 D }\xef\xbf\xbd Is decomposition of S = {S1, S2, S3} lossless, where S1 = ( A, B, C ), S2 = ( B, C, D ), and S3 = ( C, D, E )?\xef\xbf\xbd To be discussed in class 15Checking if a decomposition is Dependency-Preserving?Inputs: Let  \xe2\x89\xba\xe2\x89\xba\xe2\x89\xba\xe2\x89\xbaR,F\xe2\x89\xbb\xe2\x89\xbb\xe2\x89\xbb\xe2\x89\xbb, where F = {X1 \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 Y1,\xe2\x80\xa6, Xn \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 Yn}.Suppose R = { R1,\xe2\x80\xa6,Rk } is a decomposition of Rand Fi is the projection of F on schema RiMethod:preserved \xe2\x86\x90\xe2\x86\x90\xe2\x86\x90\xe2\x86\x90 TRUE for each FD X \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 Y in F and while preserved == TRUEdo compute X+ under F1 \xe2\x88\xaa\xe2\x88\xaa\xe2\x88\xaa\xe2\x88\xaa . . . \xe2\x88\xaa\xe2\x88\xaa\xe2\x88\xaa\xe2\x88\xaa Fk ;if Y \xe2\x8a\x88 X+ then {preserved \xe2\x86\x90\xe2\x86\x90\xe2\x86\x90\xe2\x86\x90 FALSE;  exit };end16Example\xef\xbf\xbd Consider R = ( A, B, C, D ), F = { A \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 B, B \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 C, C \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 D }\xef\xbf\xbd Is the decomposition R = {R1, R2} dependency-preserving, whereR1 = ( A, B ), F1 = { A \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 B }, R2 = ( A, C , D), AND F2 = { C \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 D, A \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 D, A \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 C }?\xef\xbf\xbd Check if A \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 B is preserved\xe2\x80\xa2 Compute A+ under { A \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 B } \xe2\x88\xaa\xe2\x88\xaa\xe2\x88\xaa\xe2\x88\xaa { C \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 D, A \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 D, A \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 C }\xe2\x80\xa2 A+ = { A, B, C, D}\xe2\x80\xa2 Check if B \xe2\x88\x88\xe2\x88\x88\xe2\x88\x88\xe2\x88\x88 A+\xe2\x80\xa2 Yes\xe2\x80\xa2 A \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92B is preserved\xef\xbf\xbd Check if B \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 C is preserved\xe2\x80\xa2 Compute B+ under { A \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 B } \xe2\x88\xaa\xe2\x88\xaa\xe2\x88\xaa\xe2\x88\xaa { C \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 D, A \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 D, A \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 C }\xe2\x80\xa2 B+ = { B } \xe2\x80\xa2 Check if C \xe2\x88\x88\xe2\x88\x88\xe2\x88\x88\xe2\x88\x88 B+\xe2\x80\xa2 No\xe2\x80\xa2 B \xe2\x86\x92\xe2\x86\x92\xe2\x86\x92\xe2\x86\x92 C is not preserved\xef\xbf\xbdThe decomposition is not dependency-preserving 17'