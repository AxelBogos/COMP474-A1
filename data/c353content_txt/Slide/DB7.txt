b'\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMicrosoft PowerPoint - DB7  -  Compatibility Mode\n\n\n1\n\nCOMP353 Databases\n\nRelational Algebra (RA) \nfor  Relational Data Model\n\nRelational Algebra (RA)\n\n\xef\x81\xae Database Query languages are specialized \nlanguages to ask for information (queries) in DB. \n\n\xef\x81\xae Relational Algebra (RA) is a query language \nassociated with the relational data model. \n\n\xef\x81\xae Queries in RA are expressions using a collection of  \noperators on relations in the DB.\n\n\xef\x81\xae The input(s) and output of a RA query are relations\n\xef\x81\xae A query is evaluated using the current instance of \n\nthe input relations to produce the output \n\nOperations in \xe2\x80\x9cstandard\xe2\x80\x9d RA\n\n\xef\x81\xae The well-known set operations\n\xef\x81\xae \xe2\x88\x9a Union ( \xe2\x8b\x83 ) \n\n\xef\x81\xae \xe2\x88\x9a Intersection  ( \xe2\x8b\x82 )\n\n\xef\x81\xae \xe2\x88\x9a Difference (\xef\x80\xad )\n\xef\x81\xae Special DB operations that select \xe2\x80\x9cparts\xe2\x80\x9d of a relation instance\n\n\xef\x81\xae Selection ( \xef\x81\xb3 ) \xe2\x80\x93 selects some rows (tuples) & discards the rest\n\xef\x81\xae Projection ( \xef\x81\xb0 ) \xe2\x80\x93 selects some columns (attributes) & discards the rest\n\n\xef\x81\xae Operations that \xe2\x80\x9ccombine\xe2\x80\x9d the tuples from the argument relations\n\xef\x81\xae \xe2\x88\x9a Cartesian product ( \xe2\x98\x93 ) \xe2\x80\x93 pairs the tuples in all possible ways\n\xef\x81\xae Join ( \xe2\x8a\xb3\xe2\x8a\xb2 ) \xe2\x80\x93 pairs particular tuples from the two input  relations\n\n\xef\x81\xae A unary operation to rename relations, called Rename ( \xef\x81\xb2 )\nNote: The output of a RA expression is an \xe2\x80\x9cunnamed\xe2\x80\x9d relation/set, i.e.,\n\nRA expressions return sets, whereas SQL returns multisets (bags)\n\nCompatibility Requirement\n\xef\x81\xae We can apply the set operators of union, intersection, \n\nand difference to instances of relations R and S if R and \nS are compatible, that is they have \xe2\x80\x9cthe same\xe2\x80\x9d schemas. \n\n\xef\x81\xae Definition: Relations S(A1,\xe2\x80\xa6,An) and R(B1,\xe2\x80\xa6,Bm) are \ncompatible if:\n(1) n=m and\n\n(2) type(Ai) = type(Bi) (or compatible types), for all 1 \xe2\x89\xa4 i \xe2\x89\xa4 n.\n\nSet Operations on Relations\nLet R and S be relation schemas, and r and s be any instances\nof them.\n\xef\x81\xae The union of r and s is the set of all tuples that appear in \n\neither one or both. Each tuple t appears only once in the \nunion, even if it appears in both; r \xef\x83\x88 s = {t |  t\xe2\x88\x88 r \xe2\x88\xa8 t \xe2\x88\x88 s}\n\n\xef\x81\xae The intersection of r and s, is the set of all tuples that \nappear in both; r \xef\x83\x87 s = {t |  t\xe2\x88\x88 r \xe2\x88\xa7 t \xe2\x88\x88 s}\n\n\xef\x81\xae The difference of r and s, is the set of all tuples that \nappear in r but not in s; r \xef\x80\xad s = {t |  t\xe2\x88\x88 r \xe2\x88\xa7 t \xe2\x88\x89 s}\n\xef\x81\xae Commutative operations; r Op s = s Op r\n\nNote: Set difference (\xef\x80\xad) is not commutative, i.e., (r\xef\x80\xad s \xe2\x89\xa0 s \xef\x80\xad r)\n\nExample\n\nInstance r \nof Star:\n\nInstance s \nof Star:\n\nName Address Gender Birthdate \n\nCarrie Fisher 123 Maple F 9/9/99\nMark Hamill 456 Oak rd. M 8/8/88\n\nName Address Gender Birthdate \n\nCarrie Fisher 123 Maple F 9/9/99\n\nHarrison Ford 789 Palm rd. M 7/7/77\n\nRelation Schema: Star (name, address, gender, birthdate )\n\nr \xef\x83\x88 s: Name Address Gender Birthdate \nCarrie Fisher 123 Maple F 9/9/99\nMark Hamill 456 Oak rd. M 8/8/88\n\nHarrison Ford 789 Palm rd. M 7/7/77\n\n1 2\n\n3 4\n\n5 6\n\n\n\n2\n\nExample\n\nInstance r \nof Star:\n\nInstance s \nof Star:\n\nName Address Gender Birthdate \n\nCarrie Fisher 123 Maple F 9/9/99\nMark Hamill 456 Oak rd. M 8/8/88\n\nName Address Gender Birthdate \n\nCarrie Fisher 123 Maple F 9/9/99\n\nHarrison Ford 789 Palm rd. M 7/7/77\n\nRelation Schema: Star (name, address, gender, birthdate )\n\nr \xef\x83\x87 s: Name Address Gender Birthdate \nCarrie Fisher 123 Maple F 9/9/99\n\nExample\n\nInstance r\nof Star:\n\nInstance s \nof Star:\n\nName Address Gender Birthdate \n\nCarrie Fisher 123 Maple F 9/9/99\nMark Hamill 456 Oak rd. M 8/8/88\n\nName Address Gender Birthdate \n\nCarrie Fisher 123 Maple F 9/9/99\n\nHarrison Ford 789 Palm rd. M 7/7/77\n\nRelation Schema: Star (name, address, gender, birthdate )\n\nr \xe2\x80\x93 s: Name Address Gender Birthdate \nMark Hamill 456 Oak rd. M 8/8/88\n\nExample\n\nInstance r\nof Star:\n\nInstance s\nof Star:\n\nName Address Gender Birthdate \n\nCarrie Fisher 123 Maple F 9/9/99\nMark Hamill 456 Oak rd. M 8/8/88\n\nName Address Gender Birthdate \n\nCarrie Fisher 123 Maple F 9/9/99\n\nHarrison Ford 789 Palm rd. M 7/7/77\n\nRelation Schema: Star (name, address, gender, birthdate)\n\ns \xe2\x80\x93 r:\nName Address Gender Birthdate \n\nHarrison Ford 789 Palm rd. M 7/7/77\n\nProjection (\xef\x81\xb0)\n\xef\x81\xae Let R be a relation schema.\n\n\xef\x81\xae The projection operation (\xef\x81\xb0) is used to \nproduce, from any instance r of R, a new \nrelation that includes listed \xe2\x80\x9ccolumns\xe2\x80\x9d of R\n\n\xef\x81\xae The output of \xef\x81\xb0A1, A2,\xe2\x80\xa6,Aj (r) is a relation with \ncolumns A1, A2,\xe2\x80\xa6, Aj, in this order.\n\n\xef\x81\xae Note: The subscript of \xef\x81\xb0 is a list, which defines \nthe structure of the output as the ordered tuple \n(A1, A2,\xe2\x80\xa6, Aj). \n\nExample\n\ntitle year length filmType studioName producer\n\nStar wars 1977 124 color Fox 12345\n\nMighty Ducks 1991 104 color Disney 67890\n\nWayne\xe2\x80\x99s World 1992 95 color Paramount 99999\n\nRelation Schema:Movie(title, year, length, filmType, studioName, producer)\n\nQuery: \xef\x81\xb0 title, year, length(movie)\n\ntitle year length\n\nStar wars 1977 124\n\nMighty Ducks 1991 104\n\nWayne\xe2\x80\x99s World 1992 95\n\nInstance \nmovie\n\nOf  Movie:\n\nExample\n\nInstance \nmovie\n\nOf Movie:\n\ntitle year length filmType studioName producer\n\nStar wars 1977 124 color Fox 12345\n\nMighty Ducks 1991 104 color Disney 67890\n\nWayne\xe2\x80\x99s World 1992 95 color Paramount 99999\n\nRelation Schema:Movie(title, year, length, filmType, studioName, producer)\n\nQuery: \xef\x81\xb0 filmType(movie)\n\nfilmType\n\ncolor\nResult:\n\n7 8\n\n9 10\n\n11 12\n\n\n\n3\n\nSelection (\xef\x81\xb3)\n\xef\x81\xae The selection operator (\xef\x81\xb3), applied to an \n\ninstance r of relation R, returns a subset of r\n\n\xef\x81\xae We denote this operation/query by \xef\x81\xb3C(r)\n\xef\x81\xae The output includes tuples satisfying condition C\n\n\xef\x81\xae The schema of the output is the same as R\n\nExample\n\nInstance movie\nof Movie:\n\ntitle year length filmType studioName producer\n\nStar wars 1977 124 color Fox 12345\n\nMighty Ducks 1991 104 color Disney 67890\n\nWayne\xe2\x80\x99s World 1992 95 color Paramount 99999\n\nRelation Schema:Movie(title, year, length, filmType, studioName, producer)\n\nQuery: \xef\x81\xb3length \xef\x82\xb3 100(movie)\n\ntitle year length filmType studioName producer\n\nStar wars 1977 124 color Fox 12345\n\nMighty Ducks 1991 104 color Disney 67890\n\nResult:\n\nExample\n\nInstance \nmovie\n\nof Movie:\n\ntitle year length filmType studioName producer\n\nStar wars 1977 124 color Fox 12345\n\nMighty Ducks 1991 104 color Disney 67890\n\nWayne\xe2\x80\x99s World 1992 95 color Paramount 99999\n\nRelation: Movie(title, year, length, filmType, studioName, producer)\n\nQuery: \xef\x81\xb3length \xef\x82\xb3 100 AND studioName = \xe2\x80\x99Fox\xe2\x80\x99 (movie)\n\ntitle year length filmType studioName producer\n\nStar wars 1977 124 color Fox 12345\nResult:\n\nCartesian Product (\xef\x82\xb4)\n\xef\x81\xae Let R and S be relation schemas, and r and s be \n\nany instances of R and S, respectively.\n\n\xef\x81\xae The Cartesian Product of r and s is the set of \nall tuples obtained by \xe2\x80\x9cconcatenating\xe2\x80\x9d the tuples \nin r and s. Formally, r \xef\x82\xb4 s = { t1.t2 | t1\xe2\x88\x88r \xe2\x88\xa7 t2\xe2\x88\x88s }\n\n\xef\x81\xae The schema of result is the \xe2\x80\x9cunion\xe2\x80\x9d of R and S\n\xef\x81\xae If R and S have some attributes in common, we \n\nneed to invent new names for identical names, e.g., \nuse R.B and S.B, if B appears in both R and S\n\nExample\nInstance s of S:Instance r of R:\n\nr \xef\x82\xb4 s:\n\nB C D\n\n2 5 6\n\n4 7 8\n\n9 10 11\n\nA B\n\n1 2\n\n3 4\n\nA R.B S.B C D\n\n1 2 2 5 6\n\n1 2 4 7 8\n\n1 2 9 10 11\n\n3 4 2 5 6\n\n3 4 4 7 8\n\n3 4 9 10 11\n\nTheta-join (\xef\x81\xb1)\n\xef\x81\xae Suppose R and S are relation schemas, r is an \n\ninstance of R, and s is an instance of S. The \ntheta-join of r and s is the set of all tuples \nobtained from concatenating all t1 \xe2\x88\x88 r and t2 \xe2\x88\x88 s, \nsuch that t1 and t2 satisfy some condition C\n\n\xef\x81\xae We denote \xef\x81\xb1-join by r \xef\x81\xb7\xef\x81\xb6c s\n\xef\x81\xae The schema of the result is the same as the \n\nschema of R \xef\x82\xb4 S (i.e., the union of R and S)\n\xef\x81\xae C is a Boolean expression, simple or complex, \n\nas in operation \xef\x81\xb3\n\n13 14\n\n15 16\n\n17 18\n\n\n\n4\n\nExample\nInstance s of S:Instance r of R:\n\nr \xef\x81\xb7\xef\x81\xb6A < D s:\n\nB C D\n\n2 3 4\n\n2 3 5\n\n7 8 10\n\nA B C\n\n1 2 3\n\n6 5 8\n\n9 7 11\n\nA R.B R.C S.B S.C D\n\n1 2 3 2 3 4\n\n1 2 3 2 3 5\n\n1 2 3 7 8 10\n\n6 5 8 7 8 10\n\n9 7 11 7 8 10\n\nEqui-join\n\xef\x81\xae The equi-join operator, is a special case of \xef\x81\xb1-join, in \n\nwhich we may only use the equality relation (=) in \ncondition C\n\n\xef\x81\xae It is denoted as r \xef\x81\xb7\xef\x81\xb6c s (i.e., the same as \xef\x81\xb1-join)\n\n\xef\x81\xae The schema of the output is the same as that of \xef\x81\xb1-join \n\nExample\nInstance s of S:Instance r of R:\n\nr \xef\x81\xb7\xef\x81\xb6R.C = S.C s:\n\nB C D\n\n2 3 4\n\n2 3 5\n\n7 8 10\n\nA B C\n\n1 2 3\n\n6 5 8\n\n9 7 11\n\nA R.B R.C S.B S.C D\n\n1 2 3 2 3 4\n\n1 2 3 2 3 5\n\n6 5 8 7 8 10\n\nNatural Join (\xef\x81\xb7\xef\x81\xb6)\n\xef\x81\xae Natural join, is a special case of equi-join, where the \n\nequalities are not explicitly specified, rather they are \nassumed implicitly on the common attributes of R and S\n\n\xef\x81\xae We denote this natural join operation by r \xef\x81\xb7\xef\x81\xb6 s \n\n\xef\x81\xae The schema of the output is similar to that of  equi-join, \nexcept that each common attribute appears only once.\n\nNote: If R and S do not have any common attribute, then\n\nthe join operation becomes Cartesian product.\n\nExample\nInstance s of S:Instance r of R:\n\nr\xef\x81\xb7\xef\x81\xb6 s:\n\nB C D\n\n2 3 4\n\n2 3 5\n\n7 8 10\n\nA B C\n\n1 2 3\n\n6 2 8\n\n9 7 3\n\nA B C D\n\n1 2 3 4\n\n1 2 3 5\n\nExpressing Queries in RA\n\xef\x81\xae Every standard RA operation has relation(s) as \n\nargument(s) and produces a relation (set) as the output \n\n(Exception is the sort operator\xef\x81\xb4 )\n\xef\x81\xae This property of RA operations (that inputs and outputs \n\nare relations) makes it possible to formulate/express \nany query by composing/nesting/grouping subqueries.\n\n\xef\x81\xae We can use parentheses for grouping, in order to \nimprove clarity and readability \n\n19 20\n\n21 22\n\n23 24\n\n\n\n5\n\nExample: RA Query \n\n\xef\x81\xae Relation schema:\nMovie (title, year, length, filmType, studioName)\n\n\xef\x81\xae Query: List the title and year of every movie made by Fox\nstudio whose length is at least 100 minutes?\n\n\xef\x81\xae One way to express this query in RA is:\n\xef\x81\xb0 title,year (\xef\x81\xb3 studioName = \xe2\x80\x99Fox\xe2\x80\x99 and length \xef\x80\xbe\xef\x80\xbd 100 (movie))\n\n\xef\x81\xae Another way:\n\xef\x81\xae Select those movie tuples that have length \xe2\x89\xa5100\n\xef\x81\xae Select those movie tuples that have studioName = \xe2\x80\x99Fox\xe2\x80\x99\n\xef\x81\xae Find the intersection of the above two results\n\xef\x81\xae Then project on the attributes title and year\n\nExample: RA Query \n\n\xef\x81\xb0title,year (\xef\x81\xb3length\xef\x82\xb3100 (movie) \xef\x83\x87 \xef\x81\xb3studioName =\xe2\x80\x99Fox\xe2\x80\x99 (movie))\n\nmovie movie\n\n\xef\x81\xb3length \xef\x82\xb3 100 \xef\x81\xb3studioName =\xe2\x80\x99Fox\xe2\x80\x99\n\n\xef\x83\x87\n\n\xef\x81\xb0title,year\n\n\xef\x81\xb0 title,year (\xef\x81\xb3 studioName = \xe2\x80\x99Fox\xe2\x80\x99 and length \xef\x80\xbe\xef\x80\xbd 100 (movie))\n\nExample: RA Query \n\xef\x81\xae Relation schema:\n\nMovie (title, year, length, filmType, studioName)\nStarsIn (title, year, starName)\n\n\xef\x81\xae Query: List the names of the stars of movies of length \xe2\x89\xa5 100 \nminutes long.\n\n\xef\x81\xae One expression in RA for this query:\n\xef\x81\xae Select movie tuples of length \xe2\x89\xa5 100\n\xef\x81\xae Join the result with relation StarsIn\n\xef\x81\xae Project on the attribute starName\n\n\xef\x81\xae Exp1: \xef\x81\xb0 starName (\xef\x81\xb3length \xef\x82\xb3 100 (movie) \xef\x81\xb7\xef\x81\xb6 starsIn)\n\xef\x81\xae Another solution: \xef\x81\xb0 starName (\xef\x81\xb3length \xef\x82\xb3 100 (movie \xef\x81\xb7\xef\x81\xb6 starsIn))\n\nRenaming Operator (\xef\x81\xb2)\n\xef\x81\xae To control manipulating the names of the attributes in \n\nformulating queries in relational algebra, we may need \nrenaming of relations. May do this for convenience too\n\n\xef\x81\xae The Renaming Operator is denoted by \xef\x81\xb2s(A1,A2,\xe2\x80\xa6,An)(r)\n\n\xef\x81\xae The result is a copy of the input relation instance r, but \nrenamed to s and its attributes to A1, \xe2\x80\xa6, An, in that order.\n\n\xef\x81\xae Use \xef\x81\xb2s(r)  to give relation r a new name s (with the same \nattributes in r)\n\nThat is, in this case, schema of s is the same as that of  r.\n\nExample\n\xef\x81\xae Query: \xef\x81\xb0 starName (\xef\x81\xb3length \xef\x82\xb3 100 (movie) \xef\x81\xb7\xef\x81\xb6 starsIn)\n\n\xef\x81\xae This query can be rewritten in 2 steps as follows: \n\n1. \xef\x81\xb2M(title, year, length, filmType, studioName) (\xef\x81\xb3length\xef\x82\xb3100 (movie))\nor even simpler as: \xef\x81\xb2M (\xef\x81\xb3length\xef\x82\xb3100 (movie)) if used in the same formula\n\n2.  Or use M := \xef\x81\xb3length\xef\x82\xb3100 (movie) as a separate formula and \nthen formulate the query as:  \xef\x81\xb0 starName (M \xef\x81\xb7\xef\x81\xb6 starsIn)\n\n\xef\x81\xae Consider takes(sid,  cid, grade)\n\n\xef\x81\xae Query: Find ID of every student who has taken at least 2 courses.\n\n\xef\x81\xae \xef\x81\xb0 takes.sid (\xef\x81\xb3(takes.sid = T.sid) and (takes.cid \xef\x82\xb9 T.cid) (takes\xef\x82\xb4 \xef\x81\xb2 T (takes)))\n\nDependent and Independent Operations\n\n\xef\x81\xae Some RA operations can be expressed based \non other operations. Examples include:\n\n\xef\x81\xae r \xef\x83\x87 s = r \xef\x80\xad (r \xef\x80\xad s)\n\n\xef\x81\xae r \xef\x81\xb7\xef\x81\xb6C s = \xef\x81\xb3C (r \xef\x82\xb4 s)\n\n\xef\x81\xae r \xef\x81\xb7\xef\x81\xb6 s = \xef\x81\xb0L(\xef\x81\xb3 r.A1 = s.A1 AND\xe2\x80\xa6 AND r.An = s.An (r \xef\x82\xb4 s)), \n\nwhere L is the list of attributes in R followed by those \n\nattributes in S that are not in R, and A1,\xe2\x80\xa6, An are \n\nthe common attributes of R and S\n\n25 26\n\n27 28\n\n29 30\n\n\n\n6\n\nRelational Algebra with Bag Semantics\n\n\xef\x81\xae Relations stored in DB are called base relations/tables.\n\n\xef\x81\xae Base relations are normally sets; no duplicates. \n\n\xef\x81\xae In some situations, e.g., during query processing, it is allowed for \nrelations to have duplicate tuples. \n\n\xef\x81\xae If duplicates are allowed in a collection, it is called bag/multiset.\n\nInstance \nr of R:\n\nA B C\n\n1 2 3\n\n6 5 8\n\n6 5 8\n\n1 2 3\n\n9 7 11\n\nHere, r is a bag\n\nWhy Bags?\n\xef\x81\xae 1. Faster projection operations\n\n\xef\x81\xae Bag projection is faster, since otherwise returning distinct values \nis expensive (as we need sorting for duplicate elimination. \n\nAnother example: Computing the bag union  (r\xe2\x8b\x83B s) is\nmuch cheaper than computing the standard set union r \xe2\x8b\x83s. \n\nFormally, if r and s have n and m tuples,  then the bag and set\n\nunion operations will cost O(n+m) and O(n*m), respectively. \n\n\xef\x81\xae 2. Correct computation with some aggregation\n\xef\x81\xae For example, to compute the average of values for attribute A in \n\nthe previous relation, we must consider the bag of those values\n\nSet Operations on Bags\n\n\xef\x81\xae r \xef\x83\x88B s, the bag union of r and s, is the bag of tuples that are in r,\nin s, or in both. If a tuple t appears n times in r, and m times in s, \nthen t appears n+m times in bag r \xef\x83\x88B s  \n\nr \xef\x83\x88B s = { t:k | t:n \xe2\x88\x88 r \xe2\x8b\x80 t:m \xe2\x88\x88 s \xe2\x8b\x80 k = n+m }\n\xef\x81\xae r \xef\x83\x87B s, the bag intersection of r and s, is the bag of tuples that \n\nappear in both r and s. If a tuple t appears n times in r, and m times \nin s, then the number of occurrences of t in bag r \xef\x83\x87B s is min(n,m)\n\nr \xef\x83\x87B s = { t:k | t:n \xe2\x88\x88 r \xe2\x8b\x80 t:m \xe2\x88\x88 s \xe2\x8b\x80 k = min(n,m) }\n\xef\x81\xae r \xef\x80\xadB s, the bag difference of r and s is defined as follows:\n\nr \xef\x80\xadB s = { t:k | t:n \xe2\x88\x88 r \xe2\x8b\x80 t:m \xe2\x88\x88 s \xe2\x8b\x80 k = max(0, n-m) }\ns \xef\x80\xadB r = { t:k | t:n \xe2\x88\x88 r \xe2\x8b\x80 t:m \xe2\x88\x88 s \xe2\x8b\x80 k = max(0, m-n) }\n\nExample\nBag s:Bag r: r \xef\x83\x88B s: A B\n\n1 2\n\n3 4\n\n1 2\n\n1 2\n\n1 2\n\n3 4\n\n3 4\n\n5 6\n\nA B\n\n1 2\n\n3 4\n\n1 2\n\n1 2\n\nA B\n\n1 2\n\n3 4\n\n3 4\n\n5 6\n\nExample\nBag s:Bag r: r \xef\x83\x87B s: A B\n\n1 2\n\n3 4\n\nA B\n\n1 2\n\n3 4\n\n1 2\n\n1 2\n\nA B\n\n1 2\n\n3 4\n\n3 4\n\n5 6\n\nExample\nBag s:Bag r: r \xe2\x80\x93B s: A B\n\n1 2\n\n1 2\n\nA B\n\n1 2\n\n3 4\n\n1 2\n\n1 2\n\nA B\n\n1 2\n\n3 4\n\n3 4\n\n5 6\n\n31 32\n\n33 34\n\n35 36\n\n\n\n7\n\nExample\nBag s:Bag r: s \xe2\x80\x93B r: A B\n\n3 4\n\n5 6\n\nA B\n\n1 2\n\n3 4\n\n1 2\n\n1 2\n\nA B\n\n1 2\n\n3 4\n\n3 4\n\n5 6\n\nBag Projection \xef\x81\xb0B\n\n\xef\x81\xae Let R be a relation scheme, and r be a collection of \ntuples over R, which could have duplicates.\n\nThe bag projection operator is used to produce, from r, \na bag of tuples over some of R.\n\n\xef\x81\xae Even when r does not have duplicates, we may get \nduplicates when projecting on some attributes of R. \n\nThat is, \xef\x81\xb0B does not eliminate the duplicates and hence  \ncorresponds exactly to the SELECT clause in SQL.\n\nExample\n\nBag r: \xef\x81\xb0BA, B (r): A B\n1 2\n\n3 4\n\n1 2\n\n1 2\n\nA B C\n\n1 2 5\n\n3 4 6\n\n1 2 7\n\n1 2 8\n\nExample\n\nInstance: title year length filmType studioName producer\nStar wars 1977 124 color Fox 12345\n\nMighty Ducks 1991 104 color Disney 67890\n\nWayne\xe2\x80\x99s World 1992 95 color Paramount 99999\n\nRelation Schema:movie(title, year, length, filmType, studioName, producer)\n\n\xef\x81\xb0BfilmType(movie):\n\nfilmType\n\ncolor\n\ncolor\n\ncolor\n\nSelection on Bags\n\n\xef\x81\xae The selection operator \xef\x81\xb3C applied to an instance \nr of relation R, will return a subset of r\n\xef\x81\xae The tuples in the output relation are those that \n\nsatisfy condition C, which involves attributes of R\n\n\xef\x81\xae Duplicates are not eliminated from the result of a \nbag-selection\n\nNote: The selection operation \xef\x81\xb3 in RA is different\nfrom the SELECT clause in SQL \n\nExample\n\nBag r: \xef\x81\xb3C \xef\x82\xb3 6 (r):A B C\n1 2 5\n\n3 4 6\n\n1 2 7\n\n1 2 7\n\nA B C\n\n3 4 6\n\n1 2 7\n\n1 2 7\n\n37 38\n\n39 40\n\n41 42\n\n\n\n8\n\nCartesian Product of Bags\n\xef\x81\xae The Cartesian Product of  bags r and s is the bag of \n\ntuples that can be formed by concatenating pairs of \ntuples, the first of which comes from r and the second \nfrom s. In symbols, r \xef\x82\xb4 s = { t1.t2 | t1\xe2\x88\x88r \xe2\x8b\x80 t2\xe2\x88\x88s }\n\xef\x81\xae Each tuple of one relation is paired with each tuple of the \n\nother, regardless of whether it is a duplicate or not\n\n\xef\x81\xae If a tuple t1 appears m times in a relation r, and a tuple t2\nappears n times in relation s, then tuple t1.t2 appears m*n\ntimes in their bag-product,  r \xef\x82\xb4 s\n\nExample\nBag s:Bag r:\n\nr \xef\x82\xb4 s:\n\nB C\n\n2 3\n\n4 5\n\n4 5\n\nA B\n\n1 2\n\n1 2\n\nA R.B S.B C\n\n1 2 2 3\n\n1 2 2 3\n\n1 2 4 5\n\n1 2 4 5\n\n1 2 4 5\n\n1 2 4 5\n\nJoin of Bags\n\xef\x81\xae The bag join is computed in the same way as the \n\nstandard join operation\n\n\xef\x81\xae Duplicates are not eliminated in a bag join operation\n\nBag s:Bag r: r \xef\x81\xb7\xef\x81\xb6 s:\n\nB C\n\n2 3\n\n4 5\n\nA B\n\n1 2\n\n1 2\n\nA B C\n\n1 2 3\n\n1 2 3\n\nConstraints on Relations\n\xef\x81\xae RA offers a convenient way to express a wide variety of \n\nconstraints, e.g., referential integrity and FD\xe2\x80\x99s.\n\n\xef\x81\xae There are two ways to express constraints in RA\n1. If r is an expression in RA, then the constraint  r = \xef\x83\x86 says:\n\n\xe2\x80\x9cr has no tuples, i.e., or r is empty\xe2\x80\x9d\n\n2. If r and s are RA expressions, then the constraint r \xef\x83\x8d s says: \n\xe2\x80\x9cevery tuple in (the result of) r is in (the result of) s\xe2\x80\x9d\n\nThese constraints hold also when r and s are bags.\n\nConstraints on Relations\n\n\xef\x81\xae Note that these two types of constraints are not \nindependent. Why? \n\xef\x81\xae The constraint r \xef\x83\x8d s could also be written as \n\nr \xef\x80\xad s = \xef\x83\x86\n\nThis follows from the definition of \xe2\x80\x9c\xef\x80\xad\xe2\x80\x9d, because r \xef\x83\x8d s iff\nr \xef\x80\xad s = \xef\x83\x86, meaning that there is no tuple in r which is not in s\n\nReferential Integrity Constraints\n\n\xef\x81\xae Referential integrity in relational data model \nmeans:\n\xef\x81\xae if there is a value v in a tuple t in a relation r, \n\nthen it is expected that v appears in a particular \ncomponent (attribute) of some tuple s in relation s\n\nE.g., if tuple (s,c,g) is in table takes(sid,cid,grade), then \nthere must be a student with sid = s and a course\nwith cid = c such that s has taken c\n\nIOW, the mentions of values s and c in takes \xe2\x80\x9crefers\xe2\x80\x9d to some \nvalues outside this relation, and these values must exist\n\n43 44\n\n45 46\n\n47 48\n\n\n\n9\n\nExample\n\xef\x81\xae Relation schemas:\n\nMovie (title, year, length, filmType)\nStarsIn (title, year, starName)\n\n\xef\x81\xae Constraint:\nthe title and year of every movie that appears in relation starsIn must appear \nalso  in movie; otherwise there is a violation in referencing in starsIn\n\n\xef\x81\xae Query in RA:\n\n\xef\x81\xae \xef\x81\xb0 title, year (starsIn) \xef\x83\x8d \xef\x81\xb0 title, year (movie) \n\nor equivalently\n\n\xef\x81\xae \xef\x81\xb0 title, year (starsIn) \xef\x80\xad \xef\x81\xb0 title, year (movie) = \xef\x83\x86\n\nFunctional Dependencies\n\n\xef\x81\xae Any functional dependency X \xe2\x86\x92 Y can be expressed \nas an expression in RA\n\n\xef\x81\xae Example:\nConsider the relation schema:\nStar (name, address, gender, birthdate)\n\n\xef\x81\xae How to express the FD: name \xef\x82\xae address in RA? \n\nFunctional Dependencies\n\xef\x81\xae Relation schema:\n\nStar (name, address, birthdate)\n\n\xef\x81\xae With the FD: name \xef\x82\xae address\n\n\xef\x81\xae The idea is that if we construct all pairs of star tuples, we must not\nfind a pair that agree on name but disagree on address\n\n\xef\x81\xae To \xe2\x80\x9cconstruct\xe2\x80\x9d the pairs in RA, we use Cartesian product, and to \nfind pairs that violate this FD, we use selection\n\n\xef\x81\xae We are then ready to express this FD by equating the result to \xe2\x88\x85, as \nfollows\xe2\x80\xa6\n\nExample\nStar:\n\n\xef\x81\xb2S1(name, address, birthdate)(star)\n\nName Address Birthdate \n\nCarrie Fisher 123 Maple 9/9/99\nMark Hamill 456 Oak rd. 8/8/88\n\nHarrison Ford 789 Palm rd. 7/7/77\n\n\xef\x81\xb2S2(name, address,birthdate)(star)\n\nName Address Birthdate \n\nCarrie Fisher 123 Maple 9/9/99\nMark Hamill 456 Oak rd. 8/8/88\n\nHarrison Ford 789 Palm rd. 7/7/77\n\nName Address Birthdate \n\nCarrie Fisher 123 Maple 9/9/99\nMark Hamill 456 Oak rd. 8/8/88\n\nHarrison Ford 789 Palm rd. 7/7/77\n\nExample\ns1 \xef\x82\xb4 s2:\n\n\xef\x81\xb3S1.name=S2.name AND S1.address \xef\x82\xb9 S2.address(s1\xef\x82\xb4s2) = \xef\x83\x86\n\nS1.Name S1.Address S1.Birthdate S2.Name S2.Address S2.Birthdate \n\nCarrie Fisher 123 Maple 9/9/99 Carrie Fisher 123 Maple 9/9/99\n\nCarrie Fisher 123 Maple 9/9/99 Mark Hamill 456 Oak rd. 8/8/88\n\nCarrie Fisher 123 Maple 9/9/99 Harrison Ford 789 Palm rd. 7/7/77\nMark Hamill 456 Oak rd. 8/8/88 Carrie Fisher 123 Maple 9/9/99\nMark Hamill 456 Oak rd. 8/8/88 Mark Hamill 456 Oak rd. 8/8/88\n\nMark Hamill 456 Oak rd. 8/8/88 Harrison Ford 789 Palm rd. 7/7/77\n\nHarrison Ford 789 Palm rd. 7/7/77 Carrie Fisher 123 Maple 9/9/99\n\nHarrison Ford 789 Palm rd. 7/7/77 Mark Hamill 456 Oak rd. 8/8/88\n\nHarrison Ford 789 Palm rd. 7/7/77 Harrison Ford 789 Palm rd. 7/7/77\n\nFunctional Dependencies\n\xef\x81\xae Relation schema:\n\nStar (name, address, birthdate)\n\n\xef\x81\xae With the FD: name \xef\x82\xae address\n\n\xef\x81\xae In RA:\n\n\xef\x81\xb3S1.name=S2.name AND S1.address\xef\x82\xb9S2.address(\xef\x81\xb2S1(star) \xef\x82\xb4 \xef\x81\xb2S2(star)) = \xef\x83\x86\n\n49 50\n\n51 52\n\n53 54\n\n\n\n10\n\nDomain Constraints\n\xef\x81\xae Relation schema:\n\nStar (name, address, gender, birthdate)\n\n\xef\x81\xae How to express the following constraint?\n\nValid values for gender are \xe2\x80\x99F\xe2\x80\x99 and \xe2\x80\x99M\xe2\x80\x99\n\n\xef\x81\xae In RA:\n\n\xef\x81\xae \xef\x81\xb3gender \xef\x82\xb9 \xe2\x80\x99F\xe2\x80\x99 AND gender \xef\x82\xb9 \xe2\x80\x99M\xe2\x80\x99 (star) = \xef\x83\x86\n\n\xef\x81\xae This is an example of domain constraints\n\nDomain Constraints\n\xef\x81\xae Relation schema:\n\nEmployee (eid, name, address, salary)\n\n\xef\x81\xae How to express the constraint:\n\nMaximum employee salaries is $150,000\n\n\xef\x81\xae In RA:\n\n\xef\x81\xae \xef\x81\xb3salary \xef\x80\xbe 150000 (employee) = \xef\x83\x86\n\n"For All" Queries (1)\n\n\xef\x81\xae Given the database schema: \nStudent(Sid, Sname, Addr)\nCourse(Cid, Cname, Credits)     \nEnrolled (Sid, Cid)\n\n\xef\x81\xae Consider the query:\n\xe2\x80\x9cFind students enrolled in all the courses."\n\n\xef\x81\xae A first attempt (below) fails! \n\n\xef\x81\xb0 Sid (Enrolled)\n\xef\x81\xae This RA query returns students enrolled in some courses. \n\xef\x81\xae So, how to correctly express \xe2\x80\x9cFor All\xe2\x80\x9d types of queries? \n\n"For All" Queries (2)\n\n\xef\x81\xae A solution strategy would be to:\n\xef\x81\xae First find the list of \xe2\x80\x9call\xe2\x80\x9d students (all guys), from which \n\nwe then subtract those who have not taken at least a \ncourse (bad guys)\n\n\xef\x81\xae Then \xe2\x80\x9cgood guys\xe2\x80\x9d, would be \xe2\x80\x9call guys\xe2\x80\x9d from which \nwe remove the \xe2\x80\x9cbad guys\xe2\x80\x9d, i.e., \n\nAnswer (Good guys) = All guys \xe2\x80\x93 Bad guys\n\n"For All" Queries (3)\n\xef\x81\xae Set of all students that we should consider: \n\nAll Courses \xe2\x86\x90 \xef\x81\xb0Cid (Course)\nAll Students \xe2\x86\x90 \xef\x81\xb0Sid (Student)\n\n\xef\x81\xae Steps to find students not enrolled in all courses \n1. Create all possible \xe2\x80\x9cstudent-course\xe2\x80\x9d pairs: \n\nAll:  SC-Pairs \xe2\x86\x90 \xef\x81\xb0Sid (Student) \xef\x82\xb4 \xef\x81\xb0Cid (Course)\n\n2.      Consider all \xe2\x80\x9cactual\xe2\x80\x9d student-course pairs (take from Enrolled)\n\n3. Using 1 & 2, we then find students not enrolled in all courses:\nBad: \xef\x81\xb0 Sid (\xef\x81\xb0Sid(Student) \xef\x82\xb4 \xef\x81\xb0Cid(Course) \xe2\x88\x92 Enrolled)\n\n\xef\x81\xae Answer: All \xe2\x88\x92 Bad\n\nThe Division Operation (\xc3\xb7)\n\n\xef\x81\xae The previous query can be conveniently and \nexpressed in RA using the division operator \xc3\xb7\n\xef\x81\xae Divide Enrolled by \xef\x81\xb0 Cid (Course)\n\nthat is,   Enrolled \xc3\xb7 \xef\x81\xb0 Cid (Course)\n\n\xef\x81\xae Schema of the result is {Sid, Cid} \xe2\x88\x92 {Cid}\n\n\xef\x81\xae R \xc3\xb7 S requires that the attributes of S to be a \nsubset of attributes of R.\n\xef\x81\xae The schema of the output would be R \xe2\x88\x92 S\n\n55 56\n\n57 58\n\n59 60\n\n\n\n11\n\nExample: Enrolled (student, sport)\n\nJim Hockey\n\nJoe Football\n\nJim Football\n\nSue Hockey\n\nFind students enrolled in all sports {Hockey, Football}.\n\nEnrolled (Student, sport)\n\nExample: Enrolled(student, sport)\n\nJim\n\nJoe\n\nSue\n\nEnrolled\n\nJim Hockey\n\nJoe Football\n\nJim Football\n\nSue Hockey\n\n\xef\x81\xb0 student (Enrolled) \xef\x82\xb4 \xef\x81\xb0 sport (Enrolled)\n\nJim Hockey\n\nJim Football\n\nJoe Hockey\n\nJoe Football\n\nSue Hockey\n\nSue Football\n\n\xe2\x88\x92\n\nJoe Hockey\n\nSue Football\n\n=\n\n\xef\x81\xb0student (Enrolled) \xe2\x88\x92\n\xef\x81\xb0student ( \xef\x81\xb0student (Enrolled) \xef\x82\xb4 \xef\x81\xb0 sport (Enrolled) \xe2\x88\x92 Enrolled )\n\nJoe\n\nSue\n\nJim is the only student \nenrolled in all sports\n\n\xe2\x88\x92 =\n\nAll Bad\n\n\xef\x83\xa8\xe2\x88\x92 = ?\n\nAnother Example\n\n\xef\x81\xae r \xc3\xb7 s = \xef\x81\xb0 R\xe2\x88\x92S (r) \xe2\x88\x92\xef\x81\xb0 R\xe2\x88\x92S (\xef\x81\xb0 R\xe2\x88\x92S (r)\xef\x82\xb4s - r))\n\xef\x81\xae Given the DB schema:\n\n\xef\x81\xae Customer(cid, name)\n\xef\x81\xae Branch(bid, district)\n\xef\x81\xae Account(cid, bid)\n\n\xef\x81\xae Query: "Find the names of all customers who have an\naccount in every branch located in the Westmount area"\n\n\xef\x81\xae Solution?\n\xef\x81\xae \xef\x81\xb0name (Customer \xef\x81\xb7\xef\x81\xb6 Account\xef\x81\xb7\xef\x81\xb6 (\xef\x81\xb3district = "Westmount" (Branch)))?\n\n\xef\x81\xae No, this returns the names of all customers who have an account at \nsome branch in Westmount, but not necessarily at every such \nbranch.\n\nDatabase:\nCustomer(cid, name),   Branch(bid, district),  Account(cid, bid)\n\n\xef\x81\xae We can apply the division operator \xc3\xb7\n\xef\x81\xae Find all customer-branch pairs (cid, bid) for which \n\ncustomer (cid) has an account at branch (bid):\n\xef\x81\xb0cid,bid (customer\xef\x81\xb7\xef\x81\xb6 account)\n\n\xef\x81\xae Divide the above by all bid\'s of branches in Westmount\n\xef\x81\xb0 bid (\xef\x81\xb3district = "Westmount" (branch))\n\n\xef\x81\xae \xef\x81\xb0name ((customer \xef\x81\xb7\xef\x81\xb6 account)\xc3\xb7 \xef\x81\xb0bid (\xef\x81\xb3district = "Westmount" (branch)))\n\n\xef\x81\xae Thus, the division operation r \xc3\xb7 s is defined as:\n\nr \xc3\xb7 s = \xef\x81\xb0 R\xe2\x88\x92S (r) \xe2\x88\x92\xef\x81\xb0 R\xe2\x88\x92S (\xef\x81\xb0 R\xe2\x88\x92S (r)\xef\x82\xb4s - r))\n\n61 62\n\n63 64\n\n\n'