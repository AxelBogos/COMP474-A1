b'Microsoft PowerPoint - DB7  -  Compatibility Mode1COMP353 DatabasesRelational Algebra (RA) for  Relational Data ModelRelational Algebra (RA)\xef\x81\xae Database Query languages are specialized languages to ask for information (queries) in DB. \xef\x81\xae Relational Algebra (RA) is a query language associated with the relational data model. \xef\x81\xae Queries in RA are expressions using a collection of  operators on relations in the DB.\xef\x81\xae The input(s) and output of a RA query are relations\xef\x81\xae A query is evaluated using the current instance of the input relations to produce the output Operations in \xe2\x80\x9cstandard\xe2\x80\x9d RA\xef\x81\xae The well-known set operations\xef\x81\xae \xe2\x88\x9a Union ( \xe2\x8b\x83 ) \xef\x81\xae \xe2\x88\x9a Intersection  ( \xe2\x8b\x82 )\xef\x81\xae \xe2\x88\x9a Difference (\xef\x80\xad )\xef\x81\xae Special DB operations that select \xe2\x80\x9cparts\xe2\x80\x9d of a relation instance\xef\x81\xae Selection ( \xef\x81\xb3 ) \xe2\x80\x93 selects some rows (tuples) & discards the rest\xef\x81\xae Projection ( \xef\x81\xb0 ) \xe2\x80\x93 selects some columns (attributes) & discards the rest\xef\x81\xae Operations that \xe2\x80\x9ccombine\xe2\x80\x9d the tuples from the argument relations\xef\x81\xae \xe2\x88\x9a Cartesian product ( \xe2\x98\x93 ) \xe2\x80\x93 pairs the tuples in all possible ways\xef\x81\xae Join ( \xe2\x8a\xb3\xe2\x8a\xb2 ) \xe2\x80\x93 pairs particular tuples from the two input  relations\xef\x81\xae A unary operation to rename relations, called Rename ( \xef\x81\xb2 )Note: The output of a RA expression is an \xe2\x80\x9cunnamed\xe2\x80\x9d relation/set, i.e.,RA expressions return sets, whereas SQL returns multisets (bags)Compatibility Requirement\xef\x81\xae We can apply the set operators of union, intersection, and difference to instances of relations R and S if R and S are compatible, that is they have \xe2\x80\x9cthe same\xe2\x80\x9d schemas. \xef\x81\xae Definition: Relations S(A1,\xe2\x80\xa6,An) and R(B1,\xe2\x80\xa6,Bm) are compatible if:(1) n=m and(2) type(Ai) = type(Bi) (or compatible types), for all 1 \xe2\x89\xa4 i \xe2\x89\xa4 n.Set Operations on RelationsLet R and S be relation schemas, and r and s be any instancesof them.\xef\x81\xae The union of r and s is the set of all tuples that appear in either one or both. Each tuple t appears only once in the union, even if it appears in both; r \xef\x83\x88 s = {t |  t\xe2\x88\x88 r \xe2\x88\xa8 t \xe2\x88\x88 s}\xef\x81\xae The intersection of r and s, is the set of all tuples that appear in both; r \xef\x83\x87 s = {t |  t\xe2\x88\x88 r \xe2\x88\xa7 t \xe2\x88\x88 s}\xef\x81\xae The difference of r and s, is the set of all tuples that appear in r but not in s; r \xef\x80\xad s = {t |  t\xe2\x88\x88 r \xe2\x88\xa7 t \xe2\x88\x89 s}\xef\x81\xae Commutative operations; r Op s = s Op rNote: Set difference (\xef\x80\xad) is not commutative, i.e., (r\xef\x80\xad s \xe2\x89\xa0 s \xef\x80\xad r)ExampleInstance r of Star:Instance s of Star:Name Address Gender Birthdate Carrie Fisher 123 Maple F 9/9/99Mark Hamill 456 Oak rd. M 8/8/88Name Address Gender Birthdate Carrie Fisher 123 Maple F 9/9/99Harrison Ford 789 Palm rd. M 7/7/77Relation Schema: Star (name, address, gender, birthdate )r \xef\x83\x88 s: Name Address Gender Birthdate Carrie Fisher 123 Maple F 9/9/99Mark Hamill 456 Oak rd. M 8/8/88Harrison Ford 789 Palm rd. M 7/7/771 23 45 62ExampleInstance r of Star:Instance s of Star:Name Address Gender Birthdate Carrie Fisher 123 Maple F 9/9/99Mark Hamill 456 Oak rd. M 8/8/88Name Address Gender Birthdate Carrie Fisher 123 Maple F 9/9/99Harrison Ford 789 Palm rd. M 7/7/77Relation Schema: Star (name, address, gender, birthdate )r \xef\x83\x87 s: Name Address Gender Birthdate Carrie Fisher 123 Maple F 9/9/99ExampleInstance rof Star:Instance s of Star:Name Address Gender Birthdate Carrie Fisher 123 Maple F 9/9/99Mark Hamill 456 Oak rd. M 8/8/88Name Address Gender Birthdate Carrie Fisher 123 Maple F 9/9/99Harrison Ford 789 Palm rd. M 7/7/77Relation Schema: Star (name, address, gender, birthdate )r \xe2\x80\x93 s: Name Address Gender Birthdate Mark Hamill 456 Oak rd. M 8/8/88ExampleInstance rof Star:Instance sof Star:Name Address Gender Birthdate Carrie Fisher 123 Maple F 9/9/99Mark Hamill 456 Oak rd. M 8/8/88Name Address Gender Birthdate Carrie Fisher 123 Maple F 9/9/99Harrison Ford 789 Palm rd. M 7/7/77Relation Schema: Star (name, address, gender, birthdate)s \xe2\x80\x93 r:Name Address Gender Birthdate Harrison Ford 789 Palm rd. M 7/7/77Projection (\xef\x81\xb0)\xef\x81\xae Let R be a relation schema.\xef\x81\xae The projection operation (\xef\x81\xb0) is used to produce, from any instance r of R, a new relation that includes listed \xe2\x80\x9ccolumns\xe2\x80\x9d of R\xef\x81\xae The output of \xef\x81\xb0A1, A2,\xe2\x80\xa6,Aj (r) is a relation with columns A1, A2,\xe2\x80\xa6, Aj, in this order.\xef\x81\xae Note: The subscript of \xef\x81\xb0 is a list, which defines the structure of the output as the ordered tuple (A1, A2,\xe2\x80\xa6, Aj). Exampletitle year length filmType studioName producerStar wars 1977 124 color Fox 12345Mighty Ducks 1991 104 color Disney 67890Wayne\xe2\x80\x99s World 1992 95 color Paramount 99999Relation Schema:Movie(title, year, length, filmType, studioName, producer)Query: \xef\x81\xb0 title, year, length(movie)title year lengthStar wars 1977 124Mighty Ducks 1991 104Wayne\xe2\x80\x99s World 1992 95Instance movieOf  Movie:ExampleInstance movieOf Movie:title year length filmType studioName producerStar wars 1977 124 color Fox 12345Mighty Ducks 1991 104 color Disney 67890Wayne\xe2\x80\x99s World 1992 95 color Paramount 99999Relation Schema:Movie(title, year, length, filmType, studioName, producer)Query: \xef\x81\xb0 filmType(movie)filmTypecolorResult:7 89 1011 123Selection (\xef\x81\xb3)\xef\x81\xae The selection operator (\xef\x81\xb3), applied to an instance r of relation R, returns a subset of r\xef\x81\xae We denote this operation/query by \xef\x81\xb3C(r)\xef\x81\xae The output includes tuples satisfying condition C\xef\x81\xae The schema of the output is the same as RExampleInstance movieof Movie:title year length filmType studioName producerStar wars 1977 124 color Fox 12345Mighty Ducks 1991 104 color Disney 67890Wayne\xe2\x80\x99s World 1992 95 color Paramount 99999Relation Schema:Movie(title, year, length, filmType, studioName, producer)Query: \xef\x81\xb3length \xef\x82\xb3 100(movie)title year length filmType studioName producerStar wars 1977 124 color Fox 12345Mighty Ducks 1991 104 color Disney 67890Result:ExampleInstance movieof Movie:title year length filmType studioName producerStar wars 1977 124 color Fox 12345Mighty Ducks 1991 104 color Disney 67890Wayne\xe2\x80\x99s World 1992 95 color Paramount 99999Relation: Movie(title, year, length, filmType, studioName, producer)Query: \xef\x81\xb3length \xef\x82\xb3 100 AND studioName = \xe2\x80\x99Fox\xe2\x80\x99 (movie)title year length filmType studioName producerStar wars 1977 124 color Fox 12345Result:Cartesian Product (\xef\x82\xb4)\xef\x81\xae Let R and S be relation schemas, and r and s be any instances of R and S, respectively.\xef\x81\xae The Cartesian Product of r and s is the set of all tuples obtained by \xe2\x80\x9cconcatenating\xe2\x80\x9d the tuples in r and s. Formally, r \xef\x82\xb4 s = { t1.t2 | t1\xe2\x88\x88r \xe2\x88\xa7 t2\xe2\x88\x88s }\xef\x81\xae The schema of result is the \xe2\x80\x9cunion\xe2\x80\x9d of R and S\xef\x81\xae If R and S have some attributes in common, we need to invent new names for identical names, e.g., use R.B and S.B, if B appears in both R and SExampleInstance s of S:Instance r of R:r \xef\x82\xb4 s:B C D2 5 64 7 89 10 11A B1 23 4A R.B S.B C D1 2 2 5 61 2 4 7 81 2 9 10 113 4 2 5 63 4 4 7 83 4 9 10 11Theta-join (\xef\x81\xb1)\xef\x81\xae Suppose R and S are relation schemas, r is an instance of R, and s is an instance of S. The theta-join of r and s is the set of all tuples obtained from concatenating all t1 \xe2\x88\x88 r and t2 \xe2\x88\x88 s, such that t1 and t2 satisfy some condition C\xef\x81\xae We denote \xef\x81\xb1-join by r \xef\x81\xb7\xef\x81\xb6c s\xef\x81\xae The schema of the result is the same as the schema of R \xef\x82\xb4 S (i.e., the union of R and S)\xef\x81\xae C is a Boolean expression, simple or complex, as in operation \xef\x81\xb313 1415 1617 184ExampleInstance s of S:Instance r of R:r \xef\x81\xb7\xef\x81\xb6A < D s:B C D2 3 42 3 57 8 10A B C1 2 36 5 89 7 11A R.B R.C S.B S.C D1 2 3 2 3 41 2 3 2 3 51 2 3 7 8 106 5 8 7 8 109 7 11 7 8 10Equi-join\xef\x81\xae The equi-join operator, is a special case of \xef\x81\xb1-join, in which we may only use the equality relation (=) in condition C\xef\x81\xae It is denoted as r \xef\x81\xb7\xef\x81\xb6c s (i.e., the same as \xef\x81\xb1-join)\xef\x81\xae The schema of the output is the same as that of \xef\x81\xb1-join ExampleInstance s of S:Instance r of R:r \xef\x81\xb7\xef\x81\xb6R.C = S.C s:B C D2 3 42 3 57 8 10A B C1 2 36 5 89 7 11A R.B R.C S.B S.C D1 2 3 2 3 41 2 3 2 3 56 5 8 7 8 10Natural Join (\xef\x81\xb7\xef\x81\xb6)\xef\x81\xae Natural join, is a special case of equi-join, where the equalities are not explicitly specified, rather they are assumed implicitly on the common attributes of R and S\xef\x81\xae We denote this natural join operation by r \xef\x81\xb7\xef\x81\xb6 s \xef\x81\xae The schema of the output is similar to that of  equi-join, except that each common attribute appears only once.Note: If R and S do not have any common attribute, thenthe join operation becomes Cartesian product.ExampleInstance s of S:Instance r of R:r\xef\x81\xb7\xef\x81\xb6 s:B C D2 3 42 3 57 8 10A B C1 2 36 2 89 7 3A B C D1 2 3 41 2 3 5Expressing Queries in RA\xef\x81\xae Every standard RA operation has relation(s) as argument(s) and produces a relation (set) as the output (Exception is the sort operator\xef\x81\xb4 )\xef\x81\xae This property of RA operations (that inputs and outputs are relations) makes it possible to formulate/express any query by composing/nesting/grouping subqueries.\xef\x81\xae We can use parentheses for grouping, in order to improve clarity and readability 19 2021 2223 245Example: RA Query \xef\x81\xae Relation schema:Movie (title, year, length, filmType, studioName)\xef\x81\xae Query: List the title and year of every movie made by Foxstudio whose length is at least 100 minutes?\xef\x81\xae One way to express this query in RA is:\xef\x81\xb0 title,year (\xef\x81\xb3 studioName = \xe2\x80\x99Fox\xe2\x80\x99 and length \xef\x80\xbe\xef\x80\xbd 100 (movie))\xef\x81\xae Another way:\xef\x81\xae Select those movie tuples that have length \xe2\x89\xa5100\xef\x81\xae Select those movie tuples that have studioName = \xe2\x80\x99Fox\xe2\x80\x99\xef\x81\xae Find the intersection of the above two results\xef\x81\xae Then project on the attributes title and yearExample: RA Query \xef\x81\xb0title,year (\xef\x81\xb3length\xef\x82\xb3100 (movie) \xef\x83\x87 \xef\x81\xb3studioName =\xe2\x80\x99Fox\xe2\x80\x99 (movie))movie movie\xef\x81\xb3length \xef\x82\xb3 100 \xef\x81\xb3studioName =\xe2\x80\x99Fox\xe2\x80\x99\xef\x83\x87\xef\x81\xb0title,year\xef\x81\xb0 title,year (\xef\x81\xb3 studioName = \xe2\x80\x99Fox\xe2\x80\x99 and length \xef\x80\xbe\xef\x80\xbd 100 (movie))Example: RA Query \xef\x81\xae Relation schema:Movie (title, year, length, filmType, studioName)StarsIn (title, year, starName)\xef\x81\xae Query: List the names of the stars of movies of length \xe2\x89\xa5 100 minutes long.\xef\x81\xae One expression in RA for this query:\xef\x81\xae Select movie tuples of length \xe2\x89\xa5 100\xef\x81\xae Join the result with relation StarsIn\xef\x81\xae Project on the attribute starName\xef\x81\xae Exp1: \xef\x81\xb0 starName (\xef\x81\xb3length \xef\x82\xb3 100 (movie) \xef\x81\xb7\xef\x81\xb6 starsIn)\xef\x81\xae Another solution: \xef\x81\xb0 starName (\xef\x81\xb3length \xef\x82\xb3 100 (movie \xef\x81\xb7\xef\x81\xb6 starsIn))Renaming Operator (\xef\x81\xb2)\xef\x81\xae To control manipulating the names of the attributes in formulating queries in relational algebra, we may need renaming of relations. May do this for convenience too\xef\x81\xae The Renaming Operator is denoted by \xef\x81\xb2s(A1,A2,\xe2\x80\xa6,An)(r)\xef\x81\xae The result is a copy of the input relation instance r, but renamed to s and its attributes to A1, \xe2\x80\xa6, An, in that order.\xef\x81\xae Use \xef\x81\xb2s(r)  to give relation r a new name s (with the same attributes in r)That is, in this case, schema of s is the same as that of  r.Example\xef\x81\xae Query: \xef\x81\xb0 starName (\xef\x81\xb3length \xef\x82\xb3 100 (movie) \xef\x81\xb7\xef\x81\xb6 starsIn)\xef\x81\xae This query can be rewritten in 2 steps as follows: 1. \xef\x81\xb2M(title, year, length, filmType, studioName) (\xef\x81\xb3length\xef\x82\xb3100 (movie))or even simpler as: \xef\x81\xb2M (\xef\x81\xb3length\xef\x82\xb3100 (movie)) if used in the same formula2.  Or use M := \xef\x81\xb3length\xef\x82\xb3100 (movie) as a separate formula and then formulate the query as:  \xef\x81\xb0 starName (M \xef\x81\xb7\xef\x81\xb6 starsIn)\xef\x81\xae Consider takes(sid,  cid, grade)\xef\x81\xae Query: Find ID of every student who has taken at least 2 courses.\xef\x81\xae \xef\x81\xb0 takes.sid (\xef\x81\xb3(takes.sid = T.sid) and (takes.cid \xef\x82\xb9 T.cid) (takes\xef\x82\xb4 \xef\x81\xb2 T (takes)))Dependent and Independent Operations\xef\x81\xae Some RA operations can be expressed based on other operations. Examples include:\xef\x81\xae r \xef\x83\x87 s = r \xef\x80\xad (r \xef\x80\xad s)\xef\x81\xae r \xef\x81\xb7\xef\x81\xb6C s = \xef\x81\xb3C (r \xef\x82\xb4 s)\xef\x81\xae r \xef\x81\xb7\xef\x81\xb6 s = \xef\x81\xb0L(\xef\x81\xb3 r.A1 = s.A1 AND\xe2\x80\xa6 AND r.An = s.An (r \xef\x82\xb4 s)), where L is the list of attributes in R followed by those attributes in S that are not in R, and A1,\xe2\x80\xa6, An are the common attributes of R and S25 2627 2829 306Relational Algebra with Bag Semantics\xef\x81\xae Relations stored in DB are called base relations/tables.\xef\x81\xae Base relations are normally sets; no duplicates. \xef\x81\xae In some situations, e.g., during query processing, it is allowed for relations to have duplicate tuples. \xef\x81\xae If duplicates are allowed in a collection, it is called bag/multiset.Instance r of R:A B C1 2 36 5 86 5 81 2 39 7 11Here, r is a bagWhy Bags?\xef\x81\xae 1. Faster projection operations\xef\x81\xae Bag projection is faster, since otherwise returning distinct values is expensive (as we need sorting for duplicate elimination. Another example: Computing the bag union  (r\xe2\x8b\x83B s) ismuch cheaper than computing the standard set union r \xe2\x8b\x83s. Formally, if r and s have n and m tuples,  then the bag and setunion operations will cost O(n+m) and O(n*m), respectively. \xef\x81\xae 2. Correct computation with some aggregation\xef\x81\xae For example, to compute the average of values for attribute A in the previous relation, we must consider the bag of those valuesSet Operations on Bags\xef\x81\xae r \xef\x83\x88B s, the bag union of r and s, is the bag of tuples that are in r,in s, or in both. If a tuple t appears n times in r, and m times in s, then t appears n+m times in bag r \xef\x83\x88B s  r \xef\x83\x88B s = { t:k | t:n \xe2\x88\x88 r \xe2\x8b\x80 t:m \xe2\x88\x88 s \xe2\x8b\x80 k = n+m }\xef\x81\xae r \xef\x83\x87B s, the bag intersection of r and s, is the bag of tuples that appear in both r and s. If a tuple t appears n times in r, and m times in s, then the number of occurrences of t in bag r \xef\x83\x87B s is min(n,m)r \xef\x83\x87B s = { t:k | t:n \xe2\x88\x88 r \xe2\x8b\x80 t:m \xe2\x88\x88 s \xe2\x8b\x80 k = min(n,m) }\xef\x81\xae r \xef\x80\xadB s, the bag difference of r and s is defined as follows:r \xef\x80\xadB s = { t:k | t:n \xe2\x88\x88 r \xe2\x8b\x80 t:m \xe2\x88\x88 s \xe2\x8b\x80 k = max(0, n-m) }s \xef\x80\xadB r = { t:k | t:n \xe2\x88\x88 r \xe2\x8b\x80 t:m \xe2\x88\x88 s \xe2\x8b\x80 k = max(0, m-n) }ExampleBag s:Bag r: r \xef\x83\x88B s: A B1 23 41 21 21 23 43 45 6A B1 23 41 21 2A B1 23 43 45 6ExampleBag s:Bag r: r \xef\x83\x87B s: A B1 23 4A B1 23 41 21 2A B1 23 43 45 6ExampleBag s:Bag r: r \xe2\x80\x93B s: A B1 21 2A B1 23 41 21 2A B1 23 43 45 631 3233 3435 367ExampleBag s:Bag r: s \xe2\x80\x93B r: A B3 45 6A B1 23 41 21 2A B1 23 43 45 6Bag Projection \xef\x81\xb0B\xef\x81\xae Let R be a relation scheme, and r be a collection of tuples over R, which could have duplicates.The bag projection operator is used to produce, from r, a bag of tuples over some of R.\xef\x81\xae Even when r does not have duplicates, we may get duplicates when projecting on some attributes of R. That is, \xef\x81\xb0B does not eliminate the duplicates and hence  corresponds exactly to the SELECT clause in SQL.ExampleBag r: \xef\x81\xb0BA, B (r): A B1 23 41 21 2A B C1 2 53 4 61 2 71 2 8ExampleInstance: title year length filmType studioName producerStar wars 1977 124 color Fox 12345Mighty Ducks 1991 104 color Disney 67890Wayne\xe2\x80\x99s World 1992 95 color Paramount 99999Relation Schema:movie(title, year, length, filmType, studioName, producer)\xef\x81\xb0BfilmType(movie):filmTypecolorcolorcolorSelection on Bags\xef\x81\xae The selection operator \xef\x81\xb3C applied to an instance r of relation R, will return a subset of r\xef\x81\xae The tuples in the output relation are those that satisfy condition C, which involves attributes of R\xef\x81\xae Duplicates are not eliminated from the result of a bag-selectionNote: The selection operation \xef\x81\xb3 in RA is differentfrom the SELECT clause in SQL ExampleBag r: \xef\x81\xb3C \xef\x82\xb3 6 (r):A B C1 2 53 4 61 2 71 2 7A B C3 4 61 2 71 2 737 3839 4041 428Cartesian Product of Bags\xef\x81\xae The Cartesian Product of  bags r and s is the bag of tuples that can be formed by concatenating pairs of tuples, the first of which comes from r and the second from s. In symbols, r \xef\x82\xb4 s = { t1.t2 | t1\xe2\x88\x88r \xe2\x8b\x80 t2\xe2\x88\x88s }\xef\x81\xae Each tuple of one relation is paired with each tuple of the other, regardless of whether it is a duplicate or not\xef\x81\xae If a tuple t1 appears m times in a relation r, and a tuple t2appears n times in relation s, then tuple t1.t2 appears m*ntimes in their bag-product,  r \xef\x82\xb4 sExampleBag s:Bag r:r \xef\x82\xb4 s:B C2 34 54 5A B1 21 2A R.B S.B C1 2 2 31 2 2 31 2 4 51 2 4 51 2 4 51 2 4 5Join of Bags\xef\x81\xae The bag join is computed in the same way as the standard join operation\xef\x81\xae Duplicates are not eliminated in a bag join operationBag s:Bag r: r \xef\x81\xb7\xef\x81\xb6 s:B C2 34 5A B1 21 2A B C1 2 31 2 3Constraints on Relations\xef\x81\xae RA offers a convenient way to express a wide variety of constraints, e.g., referential integrity and FD\xe2\x80\x99s.\xef\x81\xae There are two ways to express constraints in RA1. If r is an expression in RA, then the constraint  r = \xef\x83\x86 says:\xe2\x80\x9cr has no tuples, i.e., or r is empty\xe2\x80\x9d2. If r and s are RA expressions, then the constraint r \xef\x83\x8d s says: \xe2\x80\x9cevery tuple in (the result of) r is in (the result of) s\xe2\x80\x9dThese constraints hold also when r and s are bags.Constraints on Relations\xef\x81\xae Note that these two types of constraints are not independent. Why? \xef\x81\xae The constraint r \xef\x83\x8d s could also be written as r \xef\x80\xad s = \xef\x83\x86This follows from the definition of \xe2\x80\x9c\xef\x80\xad\xe2\x80\x9d, because r \xef\x83\x8d s iffr \xef\x80\xad s = \xef\x83\x86, meaning that there is no tuple in r which is not in sReferential Integrity Constraints\xef\x81\xae Referential integrity in relational data model means:\xef\x81\xae if there is a value v in a tuple t in a relation r, then it is expected that v appears in a particular component (attribute) of some tuple s in relation sE.g., if tuple (s,c,g) is in table takes(sid,cid,grade), then there must be a student with sid = s and a coursewith cid = c such that s has taken cIOW, the mentions of values s and c in takes \xe2\x80\x9crefers\xe2\x80\x9d to some values outside this relation, and these values must exist43 4445 4647 489Example\xef\x81\xae Relation schemas:Movie (title, year, length, filmType)StarsIn (title, year, starName)\xef\x81\xae Constraint:the title and year of every movie that appears in relation starsIn must appear also  in movie; otherwise there is a violation in referencing in starsIn\xef\x81\xae Query in RA:\xef\x81\xae \xef\x81\xb0 title, year (starsIn) \xef\x83\x8d \xef\x81\xb0 title, year (movie) or equivalently\xef\x81\xae \xef\x81\xb0 title, year (starsIn) \xef\x80\xad \xef\x81\xb0 title, year (movie) = \xef\x83\x86Functional Dependencies\xef\x81\xae Any functional dependency X \xe2\x86\x92 Y can be expressed as an expression in RA\xef\x81\xae Example:Consider the relation schema:Star (name, address, gender, birthdate)\xef\x81\xae How to express the FD: name \xef\x82\xae address in RA? Functional Dependencies\xef\x81\xae Relation schema:Star (name, address, birthdate)\xef\x81\xae With the FD: name \xef\x82\xae address\xef\x81\xae The idea is that if we construct all pairs of star tuples, we must notfind a pair that agree on name but disagree on address\xef\x81\xae To \xe2\x80\x9cconstruct\xe2\x80\x9d the pairs in RA, we use Cartesian product, and to find pairs that violate this FD, we use selection\xef\x81\xae We are then ready to express this FD by equating the result to \xe2\x88\x85, as follows\xe2\x80\xa6ExampleStar:\xef\x81\xb2S1(name, address, birthdate)(star)Name Address Birthdate Carrie Fisher 123 Maple 9/9/99Mark Hamill 456 Oak rd. 8/8/88Harrison Ford 789 Palm rd. 7/7/77\xef\x81\xb2S2(name, address,birthdate)(star)Name Address Birthdate Carrie Fisher 123 Maple 9/9/99Mark Hamill 456 Oak rd. 8/8/88Harrison Ford 789 Palm rd. 7/7/77Name Address Birthdate Carrie Fisher 123 Maple 9/9/99Mark Hamill 456 Oak rd. 8/8/88Harrison Ford 789 Palm rd. 7/7/77Examples1 \xef\x82\xb4 s2:\xef\x81\xb3S1.name=S2.name AND S1.address \xef\x82\xb9 S2.address(s1\xef\x82\xb4s2) = \xef\x83\x86S1.Name S1.Address S1.Birthdate S2.Name S2.Address S2.Birthdate Carrie Fisher 123 Maple 9/9/99 Carrie Fisher 123 Maple 9/9/99Carrie Fisher 123 Maple 9/9/99 Mark Hamill 456 Oak rd. 8/8/88Carrie Fisher 123 Maple 9/9/99 Harrison Ford 789 Palm rd. 7/7/77Mark Hamill 456 Oak rd. 8/8/88 Carrie Fisher 123 Maple 9/9/99Mark Hamill 456 Oak rd. 8/8/88 Mark Hamill 456 Oak rd. 8/8/88Mark Hamill 456 Oak rd. 8/8/88 Harrison Ford 789 Palm rd. 7/7/77Harrison Ford 789 Palm rd. 7/7/77 Carrie Fisher 123 Maple 9/9/99Harrison Ford 789 Palm rd. 7/7/77 Mark Hamill 456 Oak rd. 8/8/88Harrison Ford 789 Palm rd. 7/7/77 Harrison Ford 789 Palm rd. 7/7/77Functional Dependencies\xef\x81\xae Relation schema:Star (name, address, birthdate)\xef\x81\xae With the FD: name \xef\x82\xae address\xef\x81\xae In RA:\xef\x81\xb3S1.name=S2.name AND S1.address\xef\x82\xb9S2.address(\xef\x81\xb2S1(star) \xef\x82\xb4 \xef\x81\xb2S2(star)) = \xef\x83\x8649 5051 5253 5410Domain Constraints\xef\x81\xae Relation schema:Star (name, address, gender, birthdate)\xef\x81\xae How to express the following constraint?Valid values for gender are \xe2\x80\x99F\xe2\x80\x99 and \xe2\x80\x99M\xe2\x80\x99\xef\x81\xae In RA:\xef\x81\xae \xef\x81\xb3gender \xef\x82\xb9 \xe2\x80\x99F\xe2\x80\x99 AND gender \xef\x82\xb9 \xe2\x80\x99M\xe2\x80\x99 (star) = \xef\x83\x86\xef\x81\xae This is an example of domain constraintsDomain Constraints\xef\x81\xae Relation schema:Employee (eid, name, address, salary)\xef\x81\xae How to express the constraint:Maximum employee salaries is $150,000\xef\x81\xae In RA:\xef\x81\xae \xef\x81\xb3salary \xef\x80\xbe 150000 (employee) = \xef\x83\x86"For All" Queries (1)\xef\x81\xae Given the database schema: Student(Sid, Sname, Addr)Course(Cid, Cname, Credits)     Enrolled (Sid, Cid)\xef\x81\xae Consider the query:\xe2\x80\x9cFind students enrolled in all the courses."\xef\x81\xae A first attempt (below) fails! \xef\x81\xb0 Sid (Enrolled)\xef\x81\xae This RA query returns students enrolled in some courses. \xef\x81\xae So, how to correctly express \xe2\x80\x9cFor All\xe2\x80\x9d types of queries? "For All" Queries (2)\xef\x81\xae A solution strategy would be to:\xef\x81\xae First find the list of \xe2\x80\x9call\xe2\x80\x9d students (all guys), from which we then subtract those who have not taken at least a course (bad guys)\xef\x81\xae Then \xe2\x80\x9cgood guys\xe2\x80\x9d, would be \xe2\x80\x9call guys\xe2\x80\x9d from which we remove the \xe2\x80\x9cbad guys\xe2\x80\x9d, i.e., Answer (Good guys) = All guys \xe2\x80\x93 Bad guys"For All" Queries (3)\xef\x81\xae Set of all students that we should consider: All Courses \xe2\x86\x90 \xef\x81\xb0Cid (Course)All Students \xe2\x86\x90 \xef\x81\xb0Sid (Student)\xef\x81\xae Steps to find students not enrolled in all courses 1. Create all possible \xe2\x80\x9cstudent-course\xe2\x80\x9d pairs: All:  SC-Pairs \xe2\x86\x90 \xef\x81\xb0Sid (Student) \xef\x82\xb4 \xef\x81\xb0Cid (Course)2.      Consider all \xe2\x80\x9cactual\xe2\x80\x9d student-course pairs (take from Enrolled)3. Using 1 & 2, we then find students not enrolled in all courses:Bad: \xef\x81\xb0 Sid (\xef\x81\xb0Sid(Student) \xef\x82\xb4 \xef\x81\xb0Cid(Course) \xe2\x88\x92 Enrolled)\xef\x81\xae Answer: All \xe2\x88\x92 BadThe Division Operation (\xc3\xb7)\xef\x81\xae The previous query can be conveniently and expressed in RA using the division operator \xc3\xb7\xef\x81\xae Divide Enrolled by \xef\x81\xb0 Cid (Course)that is,   Enrolled \xc3\xb7 \xef\x81\xb0 Cid (Course)\xef\x81\xae Schema of the result is {Sid, Cid} \xe2\x88\x92 {Cid}\xef\x81\xae R \xc3\xb7 S requires that the attributes of S to be a subset of attributes of R.\xef\x81\xae The schema of the output would be R \xe2\x88\x92 S55 5657 5859 6011Example: Enrolled (student, sport)Jim HockeyJoe FootballJim FootballSue HockeyFind students enrolled in all sports {Hockey, Football}.Enrolled (Student, sport)Example: Enrolled(student, sport)JimJoeSueEnrolledJim HockeyJoe FootballJim FootballSue Hockey\xef\x81\xb0 student (Enrolled) \xef\x82\xb4 \xef\x81\xb0 sport (Enrolled)Jim HockeyJim FootballJoe HockeyJoe FootballSue HockeySue Football\xe2\x88\x92Joe HockeySue Football=\xef\x81\xb0student (Enrolled) \xe2\x88\x92\xef\x81\xb0student ( \xef\x81\xb0student (Enrolled) \xef\x82\xb4 \xef\x81\xb0 sport (Enrolled) \xe2\x88\x92 Enrolled )JoeSueJim is the only student enrolled in all sports\xe2\x88\x92 =All Bad\xef\x83\xa8\xe2\x88\x92 = ?Another Example\xef\x81\xae r \xc3\xb7 s = \xef\x81\xb0 R\xe2\x88\x92S (r) \xe2\x88\x92\xef\x81\xb0 R\xe2\x88\x92S (\xef\x81\xb0 R\xe2\x88\x92S (r)\xef\x82\xb4s - r))\xef\x81\xae Given the DB schema:\xef\x81\xae Customer(cid, name)\xef\x81\xae Branch(bid, district)\xef\x81\xae Account(cid, bid)\xef\x81\xae Query: "Find the names of all customers who have anaccount in every branch located in the Westmount area"\xef\x81\xae Solution?\xef\x81\xae \xef\x81\xb0name (Customer \xef\x81\xb7\xef\x81\xb6 Account\xef\x81\xb7\xef\x81\xb6 (\xef\x81\xb3district = "Westmount" (Branch)))?\xef\x81\xae No, this returns the names of all customers who have an account at some branch in Westmount, but not necessarily at every such branch.Database:Customer(cid, name),   Branch(bid, district),  Account(cid, bid)\xef\x81\xae We can apply the division operator \xc3\xb7\xef\x81\xae Find all customer-branch pairs (cid, bid) for which customer (cid) has an account at branch (bid):\xef\x81\xb0cid,bid (customer\xef\x81\xb7\xef\x81\xb6 account)\xef\x81\xae Divide the above by all bid\'s of branches in Westmount\xef\x81\xb0 bid (\xef\x81\xb3district = "Westmount" (branch))\xef\x81\xae \xef\x81\xb0name ((customer \xef\x81\xb7\xef\x81\xb6 account)\xc3\xb7 \xef\x81\xb0bid (\xef\x81\xb3district = "Westmount" (branch)))\xef\x81\xae Thus, the division operation r \xc3\xb7 s is defined as:r \xc3\xb7 s = \xef\x81\xb0 R\xe2\x88\x92S (r) \xe2\x88\x92\xef\x81\xb0 R\xe2\x88\x92S (\xef\x81\xb0 R\xe2\x88\x92S (r)\xef\x82\xb4s - r))61 6263 64'