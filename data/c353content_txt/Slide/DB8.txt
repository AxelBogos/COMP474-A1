b'\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMicrosoft PowerPoint - DB8.ppt [Compatibility Mode]\n\n\n1\n\nCOMP353 Databases\n\nMore on SQL Queries\n\nSQL Queries: Review\n\n\xef\xbf\xbd SQL query has a form\nSELECT . . .\n\nFROM . . .\n\nWHERE . . . ;\n\n\xef\xbf\xbd The SELECT clause says which Attribute(s) we are \ninterested in\n\n\xef\xbf\xbd The FROM clause says which Relation(s) we refer to\n\n\xef\xbf\xbd The WHERE clause says which Tuple(s) we refer to\n\nCase Insensitivity \n\n\xef\xbf\xbd SQL is case insensitive\n\n\xef\xbf\xbd So, keyword FROM maybe written as:\n\n\xef\xbf\xbd FROM  or\n\n\xef\xbf\xbd From   or\n\n\xef\xbf\xbd FrOm \n\n\xef\xbf\xbd Only in strings, SQL distinguishes between uppercase \nand the lowercase letters\n\n\xef\xbf\xbd So, the following are different strings:\n\n\xe2\x80\xa2 \xe2\x80\x99FROM\xe2\x80\x99\n\n\xe2\x80\xa2 \xe2\x80\x99From\xe2\x80\x99\n\n\xe2\x80\xa2 \xe2\x80\x99FrOm\xe2\x80\x99\n\nSelect Clause \n\n\xef\xbf\xbd In place of * in the SELECT clause, we can put any \nattribute \xe2\x80\x9cwe wish\xe2\x80\x9d to project on\n\n\xef\xbf\xbd In the SELECT clause, we can also do renaming\n\nSELECT title AS name, length AS duration\n\nFROM Movie;\n\n\xef\xbf\xbd the structure of the query output \xe2\x80\x9cappears as\xe2\x80\x9d:\n\n(name, duration)\n\nSelect Clause \n\n\xef\xbf\xbd We can also use a formula in place of an attribute\n\nSELECT title AS name, length/60 AS lengthInHours\n\nFROM Movie;\n\n\xef\xbf\xbd the structure of the output: (name, lengthInHours)\n\nSelect Clause \n\n\xef\xbf\xbd SQL even allows using a constant as an item in the \nSELECT clause, as shown below.\n\nSELECT title AS name, length/60 AS length, \xe2\x80\x99hrs.\xe2\x80\x99 AS inHours\n\nFROMMovie;\n\n\xef\xbf\xbdThe structure of the output: (name,                     length,   inHours)\n\nGone with the wind 1.98       hrs.\n\nKing Kong 0.75       hrs.\n\xef\xbf\xbd Why? To put some \xe2\x80\x9cuseful\xe2\x80\x9d words into the output that SQL displays \n\n\n\n2\n\nComparison of Strings \n\n\xef\xbf\xbd Two strings are equal if they have the same sequence of \ncharacters/symbols\n\n\xef\xbf\xbd Strings are compared alphabetically\n\xef\xbf\xbd \xe2\x80\x99fodder\xe2\x80\x99 < \xe2\x80\x99foo\xe2\x80\x99\n\n\xef\xbf\xbd \xe2\x80\x99bar\xe2\x80\x99 < \xe2\x80\x99bargain\xe2\x80\x99\n\n\xef\xbf\xbd WHERE R.A = T.B AND s LIKE p\n\n\xef\xbf\xbd s is an attribute of type string and p is a pattern; e.g. \n\nWHERE title LIKE \xe2\x80\x99Gone%\xe2\x80\x99\n\n\xef\xbf\xbd \xe2\x80\x9cOrdinary\xe2\x80\x9d characters in p matches ordinary characters in s\n\n\xef\xbf\xbd What about \xe2\x80\x9cSpecial\xe2\x80\x9d characters in p:  % , _\n\xef\xbf\xbd \xe2\x80\x9c%\xe2\x80\x9d in p matches any sequence of zero or more characters in s\n\n\xef\xbf\xbd \xe2\x80\x9c_\xe2\x80\x9d in p matches any one character in s\n\nComparison of Strings \n\n\xef\xbf\xbd Suppose we remember a movie \xe2\x80\x9cStar something\xe2\x80\x9d, and we \ndo remember that \xe2\x80\x9cthe something\xe2\x80\x9d has four letters\n\nSELECT title\n\nFROMMovie\n\nWHERE title LIKE \xe2\x80\x99Star _ _ _ _\xe2\x80\x99;\n\nSELECT title\n\nFROMMovie\n\nWHERE title LIKE \xe2\x80\x99Star%\xe2\x80\x99;\n\nComparison of Strings \n\nWhat if the pattern p includes \xe2\x80\x99, %, or _?\n\n\xef\xbf\xbd Find all movies with a possessive ( \xe2\x80\x99s ) in their title\n\nLIKE \xe2\x80\x99%\xe2\x80\x99s%\xe2\x80\x99\n\nSELECT title\n\nFROMMovie\n\nWHERE title LIKE \xe2\x80\x99%\xe2\x80\x99\xe2\x80\x99s%\xe2\x80\x99;\n\n\xef\xbf\xbd The convention is that two apostrophes \xe2\x80\x99\xe2\x80\x99 in a string represent \n\none single apostrophe (\xe2\x80\x99), and not the end of string\n\nComparison of Strings \n\n\xef\xbf\xbd What if p involves the special characters % or _? \n\xef\xbf\xbd We should \xe2\x80\x9cescape\xe2\x80\x9d their special meaning using \n\xe2\x80\x9csome\xe2\x80\x9d escape character\n\n\xef\xbf\xbd SQL allows using any character as escape character\n\n\xef\xbf\xbd s LIKE \xe2\x80\x99x%%x%\xe2\x80\x99 ESCAPE \xe2\x80\x99x\xe2\x80\x99;  \n\n\xef\xbf\xbd Here, x is the escape character \xef\xbf\xbd x% means the \ncharacter %, and not its usual meaning (the special \ncharacter)\n\n\xef\xbf\xbd The pattern \xe2\x80\x99x%%x%\xe2\x80\x99 matches strings: %whatever%\n\nOrdering the Ouput\n\n\xef\xbf\xbd We may wish the output of a query to be displayed in some \norder. This could be done using the SQL clause: \n\n\xef\xbf\xbd ORDER BY <list of attributes>\n\n\xef\xbf\xbd E.g., List Disney movies in 1990 by their length, shortest first, \nand then by the alphabetical order of the titles:\n\nSELECT *\n\nFROMMovie\n\nWHERE studioName = \xe2\x80\x99Disney\xe2\x80\x99 AND year = 1990\n\nORDER BY length, title;\n\n\xef\xbf\xbd Default ordering is ASCending, unless we use the DESC keyword\n\n\xef\xbf\xbd Ties are broken by the \xe2\x80\x9cnext\xe2\x80\x9d attribute in the ORDER BY list.\n\nProducts and Joins \n\n\xef\xbf\xbd SQL has a simple way to couple relations in a \nquery\n\n\xef\xbf\xbd How? Simply list each relation in the FROM clause\n\n\xef\xbf\xbd All the relations in the FROM clause are coupled \nthrough Cartesian product\n\n\xef\xbf\xbd Then we can put conditions in the WHERE clause \nin order to get a desired kind of join\n\n\n\n3\n\nJoin (Example, Recall)\n\n\xef\xbf\xbd Relation schemas:\n\nMovie (title, year, length, filmType)\n\nOwns (title, year, studioName)\n\n\xef\xbf\xbd Query:\n\nFind titles and lengths of all movies produced by Disney\n\n\xef\xbf\xbd Query in SQL:\n\nSELECT Movie.title, Movie.length\n\nFROMMovie, Owns\n\nWHERE Movie.title = Owns.title AND Movie.year = Owns.year \nAND Owns.studioName = \xe2\x80\x99Disney\xe2\x80\x99;\n\nUnion, Intersection, and Difference\n\n\xef\xbf\xbd We can apply the common set operations of \nunion, intersection, and difference to relations R \nand S, if they are compatible. \n\n\xef\xbf\xbd When the output of two or more SQL queries are \ncompatible, we may \xe2\x80\x9ccombine\xe2\x80\x9d the queries using:\n\n\xef\xbf\xbd UNION\n\n\xef\xbf\xbd INTERSECT\n\n\xef\xbf\xbd EXCEPT  (or MINUS in Oracle)\n\nUnion, Intersection, and Difference\n\xef\xbf\xbd Relation schemas:\n\nMovie ( title, year, length, filmType)\n\nStarsIn (title, year, starName)\n\n\xef\xbf\xbd Query:\nFind titles and years of movies that appeared in either Movie or\nStarsIn relations\n\n\xef\xbf\xbd Query in SQL:\nSELECT title, year \n\nFROMMovie\n\nUNION\n\nSELECT title, year \n\nFROM StarsIn;\n\nUnion, Intersection, and Difference\n\xef\xbf\xbd Relation schemas:\n\nStar(name, address, gender, birthdate)\nExec(name, address, cert#, netWorth)\n\n\xef\xbf\xbd Query:\nFind names and addresses of all female movie stars who are also \nmovie executives with a net worth of over $10,000,000\n\n\xef\xbf\xbd Query in SQL:\nSELECT name, address\nFROM Star\nWHERE gender = \xe2\x80\x99F\xe2\x80\x99\n\nINTERSECT\n\nSELECT name, address\nFROM Exec\nWHERE netWorth > 10000000;\n\nUnion, Intersection, and Difference\n\xef\xbf\xbd Relation schemas:\n\nStar (name, address, gender, birthdate)\nExec (name, address, cert#, netWorth)\n\n\xef\xbf\xbd Query:\nFind names and addresses of movie stars who are not movie \nexecutives\n\n\xef\xbf\xbd Query in SQL:\nSELECT name, address\n\nFROM Star\n\nEXCEPT                   //or MINUS in Oracle//\n\nSELECT name, address\n\nFROM Exec;\n\nDuplicate Elimination\n\nNote that in SQL:\n\n\xef\xbf\xbd The union, intersection, and difference operations \nnormally eliminate duplicates (the set semantics)\n\n\xef\xbf\xbd To retain duplicates, hence preventing duplicate \nelimination, we must use the keyword ALL after the \noperator UNION, INTERSECT, and EXCEPT\n\n\xef\xbf\xbd R UNION ALL S (the only bag operation supported in Oracle) \n\n\xef\xbf\xbd R INTERSECT ALL S\n\n\xef\xbf\xbd R EXCEPT ALL S\n\n\n\n4\n\nRetaining Duplicates\n\n\xef\xbf\xbd R UNION ALL S\n\n\xef\xbf\xbd The bag of elements that are in R, S, or in both. If R is a bag in which tuple t\nappears n times, and S is a bag in which t appears m times, then the number \nof occurrences of tuple t in bag R \xe2\x88\xaa\xe2\x88\xaa\xe2\x88\xaa\xe2\x88\xaa S is n + m\n\n\xef\xbf\xbd R INTERSECT ALL S\n\n\xef\xbf\xbd The bag of elements that are in both R and S. If R is a bag in which tuple t\nappears n times, and S is a bag in which t appears m times, then the number \nof occurrences of t in bag R \xe2\x88\xa9\xe2\x88\xa9\xe2\x88\xa9\xe2\x88\xa9 S is min(n,m)\n\n\xef\xbf\xbd R EXCEPT ALL S\n\n\xef\xbf\xbd The bag of elements that are in R but not in S. If R is a bag in which tuple t\nappears n times, and S is a bag in which t appears m times, then the number \nof occurrences of t in bag R \xe2\x88\x92\xe2\x88\x92\xe2\x88\x92\xe2\x88\x92 S is max(0, n - m)\n\nRetaining Duplicates in Union\n\n\xef\xbf\xbd Relation schemas:\n\nMovie ( title, year, length, filmType)\n\nStarsIn (title, year, starName)\n\n\xef\xbf\xbd Query:\nList the title and year of every movie that appears in Movie or \nStarsIn\n\n\xef\xbf\xbd Query in SQL:\n\nSELECT title, year \n\nFROMMovie\n\nUNION ALL\n\nSELECT title, year \n\nFROM StarsIn;\n\n\n'