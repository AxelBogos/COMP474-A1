b'\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMicrosoft PowerPoint - DB11.ppt [Compatibility Mode]\n\n\n1\n\nCOMP353 Databases\n\nLogical Query Languages:\n\nDatalog\n\nLogical Query Languages (Section 5.3)\n\n\xef\xbf\xbd Motivation\n\n\xef\xbf\xbd Logical if-then rules extend rather \xe2\x80\x9cnaturally\xe2\x80\x9d and easily \n\nto recursive queries; Relational algebra doesn\xe2\x80\x99t!\n\n\xe2\x80\xa2 Recursion is considered in SQL3\n\n\xef\xbf\xbd Logical rules (Datalog) form a basis for development of \n\nmany concepts and techniques in database and \n\nknowledge base systems, with many applications such \n\nas data integration\n\nDatalog\n\n\xef\xbf\xbd The head \xe2\x80\x93 the left hand side of the arrow/implication\n\n\xef\xbf\xbd The body \xe2\x80\x93 the right hand side is a conjunction (AND) of predicates \n(called subgoals)\n\n\xef\xbf\xbd NOTE: The book uses AND in the rule bodies instead of commas.\n\n\xef\xbf\xbd The head is a positive predicate (atom) and the subgoals in the rule \nbody are Atoms \n\n\xef\xbf\xbd Atom - a formula of the form  p(T1,\xe2\x80\xa6,Tn), where p is a predicate and Ti\xe2\x80\x99s are terms\n\n\xef\xbf\xbd Predicate \xe2\x80\x93 normal (ordinary) relation name (e.g., movie, p) or \n\nbuilt-in predicates (e.g., >=>=>=>= in the above example)\n\n\xef\xbf\xbd Terms (arguments) \xe2\x80\x93 In Datalog, Ti is either a variable or a constant\n\n\xef\xbf\xbd Subgoals in the rule body may be \xe2\x80\x9cnegated\xe2\x80\x9d using NOT\n\nAlongMovie(Title, Year) \xe2\x86\x90\xe2\x86\x90\xe2\x86\x90\xe2\x86\x90 movie(Title, Year, Length, Type), Length >=>=>=>= 100.\n\nAlongMovie(Title, Year) \xe2\x86\x90\xe2\x86\x90\xe2\x86\x90\xe2\x86\x90 movie(Title, Year, Length, Type) AND Length >=>=>=>= 100.\n\nDatalog\n\n\xef\xbf\xbd A variable in a rule body is called local if it appears \n\nonly in the rule body, e.g., Length and Type\n\n\xef\xbf\xbd The head is \xe2\x80\x9ctrue\xe2\x80\x9d if there are values for local \n\nvariables that make every subgoal (in the rule \n\nbody) true\n\n\xef\xbf\xbd If the body includes no negation, then the rule can \n\nbe viewed as a join of relations in the rule body \n\nfollowed by a projection on the head variable(s)\n\nlongMovie(Title, Year) \xe2\x86\x90\xe2\x86\x90\xe2\x86\x90\xe2\x86\x90 movie(Title, Year, Length, Type), Length >=>=>=>= 100.\n\nDatalog\n\n\xef\xbf\xbd This rule may be expressed in RA as:\n\n\xcf\x81\xcf\x81\xcf\x81\xcf\x81 longMovie(\xcf\x80\xcf\x80\xcf\x80\xcf\x80Title,Year(\xcf\x83\xcf\x83\xcf\x83\xcf\x83Length\xe2\x89\xa5\xe2\x89\xa5\xe2\x89\xa5\xe2\x89\xa5100 (movie)))\n\nlongMovie(Title, Year) \xe2\x86\x90\xe2\x86\x90\xe2\x86\x90\xe2\x86\x90 movie(Title, Year, Length, Type), Length >=>=>=>= 100.\n\nVariable-Based Interpretations of Rules\n\n\xef\xbf\xbd In principle, given the rule \n\n\xef\xbf\xbd r :  H \xe2\x86\x90\xe2\x86\x90\xe2\x86\x90\xe2\x86\x90 B1,\xe2\x80\xa6,Bk.\n\nwe consider all possible assignments I of values (constants in the \ndomain) to the variables in the rule. \n\n\xef\xbf\xbd Such assignments I are called interpretations.\n\n\xef\xbf\xbd For every interpretation I of the rule, if the body is true under I , \nwe add to the head relation, the tuple defined by H under I. \n\n(we only consider ground interpretations/substitutions).\n\n\xef\xbf\xbd That is, if I (Bi) is true,\xe2\x88\x80\xe2\x88\x80\xe2\x88\x80\xe2\x88\x80 i \xe2\x88\x88\xe2\x88\x88\xe2\x88\x88\xe2\x88\x88 {1,\xe2\x80\xa6,k}, then I(H) is true.\n\n\xef\xbf\xbd In this case, we say  that \xe2\x80\x9cI satisfies r\xe2\x80\x9d or \xe2\x80\x9cI is a model for r\xe2\x80\x9d,\n(this is denoted as I \xe2\x8a\xa8\xe2\x8a\xa8\xe2\x8a\xa8\xe2\x8a\xa8 r )\n\n\n\n2\n\nExample\n\nInstance r:\n\nA B\n\n1 2\n\n2 3\n\ns(X, Y) \xe2\x86\x90\xe2\x86\x90\xe2\x86\x90\xe2\x86\x90 r(X, Z), r(Z, Y), NOT r(X, Y).\n\n\xef\xbf\xbd The only assignments that make the first subgoal \n\ntrue are:\n\n1. I 1: X \xe2\x86\x92 1, Z \xe2\x86\x92 2\n\n2. I 2: X \xe2\x86\x92 2, Z \xe2\x86\x92 3.\n\n\xef\xbf\xbd In case (1), \n\n\xef\xbf\xbd Y\xe2\x86\x92 3 makes the second subgoal r(Z,Y) true\n\n\xef\xbf\xbd Since (1, 3) \xe2\x88\x89\xe2\x88\x89\xe2\x88\x89\xe2\x88\x89 r, then \xe2\x80\x9cNOT r(X,Y)\xe2\x80\x9d is also true\n\n\xef\xbf\xbd Thus, we infer tuple (1, 3) for the head relation, s\n\n\xef\xbf\xbd In case (2), \n\n\xef\xbf\xbd No value of \xe2\x80\x9cY\xe2\x80\x9d makes the second subgoal true\n\nInstance s:\n\nA B\n\n1 3\n\nTuple-Based Interpretations of Rules\n\n\xef\xbf\xbd Consider tuple variables for each positive normal \n\nsubgoals that range over their relations\n\n\xef\xbf\xbd For each assignment of tuples to each of these \n\nsubgoals, we determine the implied assignment \xce\xb8 of \n\nvalues to variables\n\n\xef\xbf\xbd If the assignment I is:\n\n\xe2\x80\xa2 consistent and also\n\n\xe2\x80\xa2 satisfies all the subgoals (normal and built-ins) in the body\n\nthen we add to the head relation, the tuple defined by \n\nthe head H under I\n\nExample\n\nInstance r:\n\nA B\n\n1 2\n\n2 3\n\ns(X, Y) \xe2\x86\x90\xe2\x86\x90\xe2\x86\x90\xe2\x86\x90 r(X, Z), r(Z, Y), NOT r(X, Y).\n\n\xef\xbf\xbd Have 4 assignments of tuples to subgoals:  \n\nr(X,Z) r(Z,Y)\n\n1. (1, 2) (1, 2)\n\n2. (1, 2) (2, 3)\n\n3. (2, 3) (1, 2)\n\n4. (2, 3) (2, 3)\n\n\xef\xbf\xbd Only the second assignment\n\xef\xbf\xbd is consistent for the value assigned to Z and \n\nsatisfies the negative subgoal \xe2\x80\x9cNOT r(X,Y)\xe2\x80\x9d\n\n\xef\xbf\xbd (1,3) is the only tuple we get for s\n\nInstance s:\n\nA B\n\n1 3\n\nDatalog Programs\n\xef\xbf\xbd A datalog program is a finite collection of rules \n\n\xef\xbf\xbd Note: while standard datalog does not allow negation, in \nour presentation here,  the programs and rules are actually \nin datalog extended with negation and built-in predicates.\n\n\xef\xbf\xbd Predicates/relations can be divided into two classes\n\xef\xbf\xbd EDB Predicates (input relations), also called FACTS\n\n\xe2\x80\xa2 Extensional database = relations stored explicitly in DB\n\n\xef\xbf\xbd IDB Predicates (derived/output relations), defined by rule(s)\n\n\xe2\x80\xa2 Intensional database \n\n\xe2\x80\xa2 They are similar to views in relational databases\n\n\xef\xbf\xbd Note: EDB predicates appear only in the rule body and \n\nIDBs appear in the head and possibly in the body\n\nOperations in Datalog\n\n\xef\xbf\xbd The usual set operations\n\n\xef\xbf\xbd Consider relation schemas r(X,Y) and s(X,Y)\n\n\xef\xbf\xbd Intersection\n\n\xe2\x80\xa2 RA:        Q = r \xe2\x88\xa9\xe2\x88\xa9\xe2\x88\xa9\xe2\x88\xa9 s       \n\n\xe2\x80\xa2 Datalog: q(X,Y) \xe2\x86\x90\xe2\x86\x90\xe2\x86\x90\xe2\x86\x90 r(X,Y), s(X,Y).\n\n\xef\xbf\xbd Union\n\n\xe2\x80\xa2 RA: Q = r \xe2\x88\xaa\xe2\x88\xaa\xe2\x88\xaa\xe2\x88\xaa s       \n\n\xe2\x80\xa2 Datalog: the following two rules:\n\n1. q(X,Y) \xe2\x86\x90\xe2\x86\x90\xe2\x86\x90\xe2\x86\x90 r(X, Y) .\n\n2. q(X,Y) \xe2\x86\x90\xe2\x86\x90\xe2\x86\x90\xe2\x86\x90 s(X, Y) .\n\n\xef\xbf\xbd Difference\n\n\xe2\x80\xa2 RA:        Q = r \xe2\x88\x92\xe2\x88\x92\xe2\x88\x92\xe2\x88\x92 s\n\n\xe2\x80\xa2 Datalog: q(X,Y) \xe2\x86\x90\xe2\x86\x90\xe2\x86\x90\xe2\x86\x90 r(X,Y), NOT s(X,Y).\n\nOperations in Datalog\n\n\xef\xbf\xbd Projection operation\n\n\xe2\x80\xa2 RA:        p = \xcf\x80\xcf\x80\xcf\x80\xcf\x80x (r)\n\n\xe2\x80\xa2 Datalog: p(X) \xe2\x86\x90\xe2\x86\x90\xe2\x86\x90\xe2\x86\x90 r(X,Y).\n\n\n\n3\n\nOperations in Datalog\n\n\xef\xbf\xbd Selection operation\n\n\xe2\x80\xa2 RA:        s = \xcf\x83X > 10 AND y = 5 (r) \n\n\xe2\x80\xa2 Datalog: s(X,Y) \xe2\x86\x90\xe2\x86\x90\xe2\x86\x90\xe2\x86\x90 r(X,Y), X >10, Y = 5.\n\nOperations in Datalog\n\n\xef\xbf\xbd Selection operation. Recall the schema of r(X,Y).\n\n\xe2\x80\xa2 RA: s = \xcf\x83\xcf\x83\xcf\x83\xcf\x83x > 10 OR y = 5 (r)\n\n\xe2\x80\xa2 Datalog: the following two rules: \n\n1. s(X, Y) \xe2\x86\x90\xe2\x86\x90\xe2\x86\x90\xe2\x86\x90 r(X, Y), X >10.\n\n2. s(X, Y) \xe2\x86\x90\xe2\x86\x90\xe2\x86\x90\xe2\x86\x90 r(X, Y), Y = 5.\n\nNote: the following Datalog program is equivalent to the above.\n\n1. s(A,B) \xe2\x86\x90\xe2\x86\x90\xe2\x86\x90\xe2\x86\x90 r(A,B),  A>10.\n\n2. s(C,D) \xe2\x86\x90\xe2\x86\x90\xe2\x86\x90\xe2\x86\x90 r(C,D), D = 5.\n\nOperations in Datalog\n\n\xef\xbf\xbd Cartesian Product operation\n\n\xef\xbf\xbd Consider relation schemas   r(A, B) and s(C, D)\n\n\xe2\x80\xa2 RA:        Q = r \xc3\x97\xc3\x97\xc3\x97\xc3\x97 s\n\n\xe2\x80\xa2 Datalog: q(X, Y, Z, W) \xe2\x86\x90\xe2\x86\x90\xe2\x86\x90\xe2\x86\x90 r(X,Y), s(Z,W).\n\nOperations in Datalog\n\n\xef\xbf\xbd Join operation\n\n\xef\xbf\xbd Theta-join with an AND condition, e.g.,  \xe2\x80\x9cc1 AND c2\xe2\x80\x9d\n\n\xe2\x80\xa2 RA:          tj1 = r \xef\xbf\xbd\xef\xbf\xbd\xef\xbf\xbd\xef\xbf\xbd\xef\xbf\xbd\xef\xbf\xbd\xef\xbf\xbd\xef\xbf\xbd X > Z AND Y < W s\n\n\xe2\x80\xa2 Datalog:   tj1(X, Y, Z, W) \xe2\x86\x90 r(X,Y), s(Z,W), X > Z, Y < W.\n\n\xef\xbf\xbd Theta-join with an OR condition, e.g.,  \xe2\x80\x9cc1 OR c2\xe2\x80\x9d\n\n\xe2\x80\xa2 RA:   tj2 = r \xef\xbf\xbd\xef\xbf\xbd\xef\xbf\xbd\xef\xbf\xbd\xef\xbf\xbd\xef\xbf\xbd\xef\xbf\xbd\xef\xbf\xbd X > Z OR Y < W s\n\n\xe2\x80\xa2 Datalog: the following two rules:\n\ntj2(X, Y, Z, W) \xe2\x86\x90 r(X,Y), s(Z, W), X > Z.\n\ntj2(X, Y, Z, W) \xe2\x86\x90 r(X,Y), s(Z,W), Y < W.\n\nOperations in Datalog\n\n\xef\xbf\xbd Join operation\n\n\xef\xbf\xbd Equi-join\n\n\xe2\x80\xa2 RA:         ej3 = r \xef\xbf\xbd\xef\xbf\xbd\xef\xbf\xbd\xef\xbf\xbd\xef\xbf\xbd\xef\xbf\xbd\xef\xbf\xbd\xef\xbf\xbd Y = Z s\n\n\xe2\x80\xa2 Datalog:  ej3(X,Y,Z,W) \xe2\x86\x90\xe2\x86\x90\xe2\x86\x90\xe2\x86\x90 r(X,Y), s(Z,W), Y = Z.\n\nOR even better (simpler):\n\nej3(X,Y,Y,W) \xe2\x86\x90\xe2\x86\x90\xe2\x86\x90\xe2\x86\x90 r(X,Y), s(Y,W).\n\nOperations in Datalog\n\n\xef\xbf\xbd Join operation\n\n\xef\xbf\xbd Natural join\n\n\xe2\x80\xa2 RA:         nj4 = r \xef\xbf\xbd\xef\xbf\xbd\xef\xbf\xbd\xef\xbf\xbd\xef\xbf\xbd\xef\xbf\xbd\xef\xbf\xbd\xef\xbf\xbd s\n\n\xe2\x80\xa2 Datalog: nj4(X,Y,W) \xe2\x86\x90 r(X,Y), s(Y,W).\n\n\n\n4\n\nExample:Datalog Queries/Programs \n\xef\xbf\xbd Database schema:\n\nmovie( Title, Year, Length, FilmType, StudioName)\nstarsIn( Title, Year, StarName)\n\n\xef\xbf\xbd Query:  Find the names of stars of movies that are at least 100 minutes long\n\n\xef\xbf\xbd Relational Algebra Expression:\n\nQ = \xcf\x80\xcf\x80\xcf\x80\xcf\x80 starName (\xcf\x83\xcf\x83\xcf\x83\xcf\x83length\xe2\x89\xa5\xe2\x89\xa5\xe2\x89\xa5\xe2\x89\xa5100 (movie) \xef\xbf\xbd\xef\xbf\xbd\xef\xbf\xbd\xef\xbf\xbd\xef\xbf\xbd\xef\xbf\xbd\xef\xbf\xbd\xef\xbf\xbd starsIn )\n\n\xef\xbf\xbd Datalog program:\n\nr1(Title, Year, Length, Type, Studio) \xe2\x86\x90\xe2\x86\x90\xe2\x86\x90\xe2\x86\x90\n\nmovie(Title, Year, Length, Type, Studio), Length >=>=>=>= 100.\n\nr2(Title, Year, Length, Type, Studio, Name) \xe2\x86\x90\xe2\x86\x90\xe2\x86\x90\xe2\x86\x90\n\nr1(Title, Year, Length, Type, Studio), starsIn(Title, Year, Name).\n\nq(Name) \xe2\x86\x90\xe2\x86\x90\xe2\x86\x90\xe2\x86\x90 r2(Title, Year, Length, Type, Studio, Name).\n\nAs in RA case, we could express this query using just one rule,  as follows:\n\nq(Name) \xe2\x86\x90\xe2\x86\x90\xe2\x86\x90\xe2\x86\x90 movie(Title, Year, Length, Type, Studio), Length >=>=>=>= 100,\n\nstarsIn(Title, Year, Name).\n\nExpressive Power of Datalog\n\n\xef\xbf\xbd Relational algebra = Nonrecursive Datalog+ negation\n\n\xef\xbf\xbd Datalog can express SQL SELECT-FROM-WHERE statements that \n\ndo not use aggregation and/or grouping\n\n\xef\xbf\xbd The SQL-99 standard supports recursion but it is not part of the \n\n\xe2\x80\x9ccore\xe2\x80\x9d SQL-99 standard that every DBMS should support\n\n\xef\xbf\xbd Some DBMS implementations, e.g. DB2, support linear recursion\n\nExample\n\ntrainSchedule:\nFrom To\n\nToronto Calgary\n\nNYC Boston\n\nNYC Albany\n\nChicago Detroit\n\nMontreal Toronto\n\nMontreal NYC\n\nBoston Quebec City\n\ntrainSchedule(From,To)\n\nfromMontreal:\n\n\xef\xbf\xbd Datalog:\n\n\xef\xbf\xbd fromMontreal(C) \xe2\x86\x90\xe2\x86\x90\xe2\x86\x90\xe2\x86\x90 trainSchedule(\xe2\x80\x98Montreal\xe2\x80\x99, C).\n\n\xef\xbf\xbd Find every cities that can be \n\nreached from Montreal by train\n\nToronto\n\nNYC\n\nCalgary\n\nBoston\n\nAlbany\n\nQuebec City\n\n\xef\xbf\xbd fromMontreal(TC) \xe2\x86\x90\xe2\x86\x90\xe2\x86\x90\xe2\x86\x90 fromMontreal(C), trainSchedule(C,TC).\n\nEvaluation of Recursive Rules\n\nStart IDB = \xe2\x88\x85\xe2\x88\x85\xe2\x88\x85\xe2\x88\x85\n\nApply rules \n\nw.r.t  IDB & \n\nEDB\n\nyes\n\nno\n\ndone\nChange\n\nto IDB?\n\nExample\n\nInstance: Movie Sequel\n\nStar wars Star wars II\n\nNaked Gun Naked Gun 2 \n\nNaked Gun 2 Naked Gun 2 \xc2\xbd \n\nStar wars II Star wars III \n\nNaked Gun 2 \xc2\xbd Naked Gun 3 \n\nRelation Schema: sequelOf(Movie,Sequel)\n\nFor a given movie, find all the \n\nfollow-up movies, i.e., a sequel, a \n\nsequel of a sequel, and so on\n\nExample\n\nInstance: Movie Sequel\n\nStar wars Star wars II\n\nNaked Gun Naked Gun 2 \n\nNaked Gun 2 Naked Gun 2 \xc2\xbd \n\nStar wars II Star wars III \n\nNaked Gun 2 \xc2\xbd Naked Gun 3 \n\nRelation Schema: sequelOf(Movie, Sequel)\n\nfollowUp(X, Y) \xe2\x86\x90\xe2\x86\x90\xe2\x86\x90\xe2\x86\x90 sequelOf(X,Y).\n\nfollowUp(X, Y) \xe2\x86\x90\xe2\x86\x90\xe2\x86\x90\xe2\x86\x90 sequelOf(X,Z), followUp(Z,Y).\n\n\n\n5\n\nRecursion\n\n\xef\xbf\xbd Let P be any datalog program\n\n\xef\xbf\xbd We say an IDB predicate r in P depends on predicate s \n\nif there is a rule in P with r as the head and s as a \n\nsubgoal in the rule body\n\n\xef\xbf\xbd Construct the (dependency) graph of P:\n\n\xef\xbf\xbd Nodes -- IDB predicates in P\n\n\xef\xbf\xbd Arcs -- an arc from node r to s if r depends on s\n\n\xef\xbf\xbd Label the arc with \xe2\x80\x98\xc2\xac\xc2\xac\xc2\xac\xc2\xac\xe2\x80\x98 for negated subgoals\n\n\xef\xbf\xbd P is recursive iff its dependency graph has a cycle\n\nExample\n\nfollowUp\n\nfollowUp(X, Y) \xe2\x86\x90\xe2\x86\x90\xe2\x86\x90\xe2\x86\x90 sequelOf(X,Y).\n\nfollowUp(X, Y) \xe2\x86\x90\xe2\x86\x90\xe2\x86\x90\xe2\x86\x90 sequelOf(X,Z), followUp(Z, Y).\n\nSafety\n\n\xef\xbf\xbd It is possible to write a rule that makes \xe2\x80\x9cno sense\xe2\x80\x9d.\n\n\xef\xbf\xbd Example of such rules:\n\xef\xbf\xbd s(X) \xe2\x86\x90 r(Y).\n\n\xef\xbf\xbd s(X) \xe2\x86\x90 NOT r(X).\n\n\xef\xbf\xbd s(X) \xe2\x86\x90 r(Y), X < Y.\n\n\xef\xbf\xbd In each of these rules, the IDB relation s (output relation) \ncould be infinite, even if (the input) relation r is finite\n\n\xef\xbf\xbd Such rules are said to be not SAFE\n\nSafety\n\n\xef\xbf\xbd For a rule to be safe, the following conditions must hold:\n\n\xef\xbf\xbd If a variable X appears in the rule head, then X must \n\nappear in an \xe2\x80\x9cordinary\xe2\x80\x9d predicate in the body or be \n\nequal to such a variable (directly or indirectly), e.g., \n\nX=Y, and Y appears in an ordinary predicate in the \n\nrule body.\n\nRecall: the predicates could be ordinary or built-in.\n\n\n'