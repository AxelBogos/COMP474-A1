b'Microsoft PowerPoint - DB11.ppt [Compatibility Mode]1COMP353 DatabasesLogical Query Languages:DatalogLogical Query Languages (Section 5.3)\xef\xbf\xbd Motivation\xef\xbf\xbd Logical if-then rules extend rather \xe2\x80\x9cnaturally\xe2\x80\x9d and easily to recursive queries; Relational algebra doesn\xe2\x80\x99t!\xe2\x80\xa2 Recursion is considered in SQL3\xef\xbf\xbd Logical rules (Datalog) form a basis for development of many concepts and techniques in database and knowledge base systems, with many applications such as data integrationDatalog\xef\xbf\xbd The head \xe2\x80\x93 the left hand side of the arrow/implication\xef\xbf\xbd The body \xe2\x80\x93 the right hand side is a conjunction (AND) of predicates (called subgoals)\xef\xbf\xbd NOTE: The book uses AND in the rule bodies instead of commas.\xef\xbf\xbd The head is a positive predicate (atom) and the subgoals in the rule body are Atoms \xef\xbf\xbd Atom - a formula of the form  p(T1,\xe2\x80\xa6,Tn), where p is a predicate and Ti\xe2\x80\x99s are terms\xef\xbf\xbd Predicate \xe2\x80\x93 normal (ordinary) relation name (e.g., movie, p) or built-in predicates (e.g., >=>=>=>= in the above example)\xef\xbf\xbd Terms (arguments) \xe2\x80\x93 In Datalog, Ti is either a variable or a constant\xef\xbf\xbd Subgoals in the rule body may be \xe2\x80\x9cnegated\xe2\x80\x9d using NOTAlongMovie(Title, Year) \xe2\x86\x90\xe2\x86\x90\xe2\x86\x90\xe2\x86\x90 movie(Title, Year, Length, Type), Length >=>=>=>= 100.AlongMovie(Title, Year) \xe2\x86\x90\xe2\x86\x90\xe2\x86\x90\xe2\x86\x90 movie(Title, Year, Length, Type) AND Length >=>=>=>= 100.Datalog\xef\xbf\xbd A variable in a rule body is called local if it appears only in the rule body, e.g., Length and Type\xef\xbf\xbd The head is \xe2\x80\x9ctrue\xe2\x80\x9d if there are values for local variables that make every subgoal (in the rule body) true\xef\xbf\xbd If the body includes no negation, then the rule can be viewed as a join of relations in the rule body followed by a projection on the head variable(s)longMovie(Title, Year) \xe2\x86\x90\xe2\x86\x90\xe2\x86\x90\xe2\x86\x90 movie(Title, Year, Length, Type), Length >=>=>=>= 100.Datalog\xef\xbf\xbd This rule may be expressed in RA as:\xcf\x81\xcf\x81\xcf\x81\xcf\x81 longMovie(\xcf\x80\xcf\x80\xcf\x80\xcf\x80Title,Year(\xcf\x83\xcf\x83\xcf\x83\xcf\x83Length\xe2\x89\xa5\xe2\x89\xa5\xe2\x89\xa5\xe2\x89\xa5100 (movie)))longMovie(Title, Year) \xe2\x86\x90\xe2\x86\x90\xe2\x86\x90\xe2\x86\x90 movie(Title, Year, Length, Type), Length >=>=>=>= 100.Variable-Based Interpretations of Rules\xef\xbf\xbd In principle, given the rule \xef\xbf\xbd r :  H \xe2\x86\x90\xe2\x86\x90\xe2\x86\x90\xe2\x86\x90 B1,\xe2\x80\xa6,Bk.we consider all possible assignments I of values (constants in the domain) to the variables in the rule. \xef\xbf\xbd Such assignments I are called interpretations.\xef\xbf\xbd For every interpretation I of the rule, if the body is true under I , we add to the head relation, the tuple defined by H under I. (we only consider ground interpretations/substitutions).\xef\xbf\xbd That is, if I (Bi) is true,\xe2\x88\x80\xe2\x88\x80\xe2\x88\x80\xe2\x88\x80 i \xe2\x88\x88\xe2\x88\x88\xe2\x88\x88\xe2\x88\x88 {1,\xe2\x80\xa6,k}, then I(H) is true.\xef\xbf\xbd In this case, we say  that \xe2\x80\x9cI satisfies r\xe2\x80\x9d or \xe2\x80\x9cI is a model for r\xe2\x80\x9d,(this is denoted as I \xe2\x8a\xa8\xe2\x8a\xa8\xe2\x8a\xa8\xe2\x8a\xa8 r )2ExampleInstance r:A B1 22 3s(X, Y) \xe2\x86\x90\xe2\x86\x90\xe2\x86\x90\xe2\x86\x90 r(X, Z), r(Z, Y), NOT r(X, Y).\xef\xbf\xbd The only assignments that make the first subgoal true are:1. I 1: X \xe2\x86\x92 1, Z \xe2\x86\x92 22. I 2: X \xe2\x86\x92 2, Z \xe2\x86\x92 3.\xef\xbf\xbd In case (1), \xef\xbf\xbd Y\xe2\x86\x92 3 makes the second subgoal r(Z,Y) true\xef\xbf\xbd Since (1, 3) \xe2\x88\x89\xe2\x88\x89\xe2\x88\x89\xe2\x88\x89 r, then \xe2\x80\x9cNOT r(X,Y)\xe2\x80\x9d is also true\xef\xbf\xbd Thus, we infer tuple (1, 3) for the head relation, s\xef\xbf\xbd In case (2), \xef\xbf\xbd No value of \xe2\x80\x9cY\xe2\x80\x9d makes the second subgoal trueInstance s:A B1 3Tuple-Based Interpretations of Rules\xef\xbf\xbd Consider tuple variables for each positive normal subgoals that range over their relations\xef\xbf\xbd For each assignment of tuples to each of these subgoals, we determine the implied assignment \xce\xb8 of values to variables\xef\xbf\xbd If the assignment I is:\xe2\x80\xa2 consistent and also\xe2\x80\xa2 satisfies all the subgoals (normal and built-ins) in the bodythen we add to the head relation, the tuple defined by the head H under IExampleInstance r:A B1 22 3s(X, Y) \xe2\x86\x90\xe2\x86\x90\xe2\x86\x90\xe2\x86\x90 r(X, Z), r(Z, Y), NOT r(X, Y).\xef\xbf\xbd Have 4 assignments of tuples to subgoals:  r(X,Z) r(Z,Y)1. (1, 2) (1, 2)2. (1, 2) (2, 3)3. (2, 3) (1, 2)4. (2, 3) (2, 3)\xef\xbf\xbd Only the second assignment\xef\xbf\xbd is consistent for the value assigned to Z and satisfies the negative subgoal \xe2\x80\x9cNOT r(X,Y)\xe2\x80\x9d\xef\xbf\xbd (1,3) is the only tuple we get for sInstance s:A B1 3Datalog Programs\xef\xbf\xbd A datalog program is a finite collection of rules \xef\xbf\xbd Note: while standard datalog does not allow negation, in our presentation here,  the programs and rules are actually in datalog extended with negation and built-in predicates.\xef\xbf\xbd Predicates/relations can be divided into two classes\xef\xbf\xbd EDB Predicates (input relations), also called FACTS\xe2\x80\xa2 Extensional database = relations stored explicitly in DB\xef\xbf\xbd IDB Predicates (derived/output relations), defined by rule(s)\xe2\x80\xa2 Intensional database \xe2\x80\xa2 They are similar to views in relational databases\xef\xbf\xbd Note: EDB predicates appear only in the rule body and IDBs appear in the head and possibly in the bodyOperations in Datalog\xef\xbf\xbd The usual set operations\xef\xbf\xbd Consider relation schemas r(X,Y) and s(X,Y)\xef\xbf\xbd Intersection\xe2\x80\xa2 RA:        Q = r \xe2\x88\xa9\xe2\x88\xa9\xe2\x88\xa9\xe2\x88\xa9 s       \xe2\x80\xa2 Datalog: q(X,Y) \xe2\x86\x90\xe2\x86\x90\xe2\x86\x90\xe2\x86\x90 r(X,Y), s(X,Y).\xef\xbf\xbd Union\xe2\x80\xa2 RA: Q = r \xe2\x88\xaa\xe2\x88\xaa\xe2\x88\xaa\xe2\x88\xaa s       \xe2\x80\xa2 Datalog: the following two rules:1. q(X,Y) \xe2\x86\x90\xe2\x86\x90\xe2\x86\x90\xe2\x86\x90 r(X, Y) .2. q(X,Y) \xe2\x86\x90\xe2\x86\x90\xe2\x86\x90\xe2\x86\x90 s(X, Y) .\xef\xbf\xbd Difference\xe2\x80\xa2 RA:        Q = r \xe2\x88\x92\xe2\x88\x92\xe2\x88\x92\xe2\x88\x92 s\xe2\x80\xa2 Datalog: q(X,Y) \xe2\x86\x90\xe2\x86\x90\xe2\x86\x90\xe2\x86\x90 r(X,Y), NOT s(X,Y).Operations in Datalog\xef\xbf\xbd Projection operation\xe2\x80\xa2 RA:        p = \xcf\x80\xcf\x80\xcf\x80\xcf\x80x (r)\xe2\x80\xa2 Datalog: p(X) \xe2\x86\x90\xe2\x86\x90\xe2\x86\x90\xe2\x86\x90 r(X,Y).3Operations in Datalog\xef\xbf\xbd Selection operation\xe2\x80\xa2 RA:        s = \xcf\x83X > 10 AND y = 5 (r) \xe2\x80\xa2 Datalog: s(X,Y) \xe2\x86\x90\xe2\x86\x90\xe2\x86\x90\xe2\x86\x90 r(X,Y), X >10, Y = 5.Operations in Datalog\xef\xbf\xbd Selection operation. Recall the schema of r(X,Y).\xe2\x80\xa2 RA: s = \xcf\x83\xcf\x83\xcf\x83\xcf\x83x > 10 OR y = 5 (r)\xe2\x80\xa2 Datalog: the following two rules: 1. s(X, Y) \xe2\x86\x90\xe2\x86\x90\xe2\x86\x90\xe2\x86\x90 r(X, Y), X >10.2. s(X, Y) \xe2\x86\x90\xe2\x86\x90\xe2\x86\x90\xe2\x86\x90 r(X, Y), Y = 5.Note: the following Datalog program is equivalent to the above.1. s(A,B) \xe2\x86\x90\xe2\x86\x90\xe2\x86\x90\xe2\x86\x90 r(A,B),  A>10.2. s(C,D) \xe2\x86\x90\xe2\x86\x90\xe2\x86\x90\xe2\x86\x90 r(C,D), D = 5.Operations in Datalog\xef\xbf\xbd Cartesian Product operation\xef\xbf\xbd Consider relation schemas   r(A, B) and s(C, D)\xe2\x80\xa2 RA:        Q = r \xc3\x97\xc3\x97\xc3\x97\xc3\x97 s\xe2\x80\xa2 Datalog: q(X, Y, Z, W) \xe2\x86\x90\xe2\x86\x90\xe2\x86\x90\xe2\x86\x90 r(X,Y), s(Z,W).Operations in Datalog\xef\xbf\xbd Join operation\xef\xbf\xbd Theta-join with an AND condition, e.g.,  \xe2\x80\x9cc1 AND c2\xe2\x80\x9d\xe2\x80\xa2 RA:          tj1 = r \xef\xbf\xbd\xef\xbf\xbd\xef\xbf\xbd\xef\xbf\xbd\xef\xbf\xbd\xef\xbf\xbd\xef\xbf\xbd\xef\xbf\xbd X > Z AND Y < W s\xe2\x80\xa2 Datalog:   tj1(X, Y, Z, W) \xe2\x86\x90 r(X,Y), s(Z,W), X > Z, Y < W.\xef\xbf\xbd Theta-join with an OR condition, e.g.,  \xe2\x80\x9cc1 OR c2\xe2\x80\x9d\xe2\x80\xa2 RA:   tj2 = r \xef\xbf\xbd\xef\xbf\xbd\xef\xbf\xbd\xef\xbf\xbd\xef\xbf\xbd\xef\xbf\xbd\xef\xbf\xbd\xef\xbf\xbd X > Z OR Y < W s\xe2\x80\xa2 Datalog: the following two rules:tj2(X, Y, Z, W) \xe2\x86\x90 r(X,Y), s(Z, W), X > Z.tj2(X, Y, Z, W) \xe2\x86\x90 r(X,Y), s(Z,W), Y < W.Operations in Datalog\xef\xbf\xbd Join operation\xef\xbf\xbd Equi-join\xe2\x80\xa2 RA:         ej3 = r \xef\xbf\xbd\xef\xbf\xbd\xef\xbf\xbd\xef\xbf\xbd\xef\xbf\xbd\xef\xbf\xbd\xef\xbf\xbd\xef\xbf\xbd Y = Z s\xe2\x80\xa2 Datalog:  ej3(X,Y,Z,W) \xe2\x86\x90\xe2\x86\x90\xe2\x86\x90\xe2\x86\x90 r(X,Y), s(Z,W), Y = Z.OR even better (simpler):ej3(X,Y,Y,W) \xe2\x86\x90\xe2\x86\x90\xe2\x86\x90\xe2\x86\x90 r(X,Y), s(Y,W).Operations in Datalog\xef\xbf\xbd Join operation\xef\xbf\xbd Natural join\xe2\x80\xa2 RA:         nj4 = r \xef\xbf\xbd\xef\xbf\xbd\xef\xbf\xbd\xef\xbf\xbd\xef\xbf\xbd\xef\xbf\xbd\xef\xbf\xbd\xef\xbf\xbd s\xe2\x80\xa2 Datalog: nj4(X,Y,W) \xe2\x86\x90 r(X,Y), s(Y,W).4Example:Datalog Queries/Programs \xef\xbf\xbd Database schema:movie( Title, Year, Length, FilmType, StudioName)starsIn( Title, Year, StarName)\xef\xbf\xbd Query:  Find the names of stars of movies that are at least 100 minutes long\xef\xbf\xbd Relational Algebra Expression:Q = \xcf\x80\xcf\x80\xcf\x80\xcf\x80 starName (\xcf\x83\xcf\x83\xcf\x83\xcf\x83length\xe2\x89\xa5\xe2\x89\xa5\xe2\x89\xa5\xe2\x89\xa5100 (movie) \xef\xbf\xbd\xef\xbf\xbd\xef\xbf\xbd\xef\xbf\xbd\xef\xbf\xbd\xef\xbf\xbd\xef\xbf\xbd\xef\xbf\xbd starsIn )\xef\xbf\xbd Datalog program:r1(Title, Year, Length, Type, Studio) \xe2\x86\x90\xe2\x86\x90\xe2\x86\x90\xe2\x86\x90movie(Title, Year, Length, Type, Studio), Length >=>=>=>= 100.r2(Title, Year, Length, Type, Studio, Name) \xe2\x86\x90\xe2\x86\x90\xe2\x86\x90\xe2\x86\x90r1(Title, Year, Length, Type, Studio), starsIn(Title, Year, Name).q(Name) \xe2\x86\x90\xe2\x86\x90\xe2\x86\x90\xe2\x86\x90 r2(Title, Year, Length, Type, Studio, Name).As in RA case, we could express this query using just one rule,  as follows:q(Name) \xe2\x86\x90\xe2\x86\x90\xe2\x86\x90\xe2\x86\x90 movie(Title, Year, Length, Type, Studio), Length >=>=>=>= 100,starsIn(Title, Year, Name).Expressive Power of Datalog\xef\xbf\xbd Relational algebra = Nonrecursive Datalog+ negation\xef\xbf\xbd Datalog can express SQL SELECT-FROM-WHERE statements that do not use aggregation and/or grouping\xef\xbf\xbd The SQL-99 standard supports recursion but it is not part of the \xe2\x80\x9ccore\xe2\x80\x9d SQL-99 standard that every DBMS should support\xef\xbf\xbd Some DBMS implementations, e.g. DB2, support linear recursionExampletrainSchedule:From ToToronto CalgaryNYC BostonNYC AlbanyChicago DetroitMontreal TorontoMontreal NYCBoston Quebec CitytrainSchedule(From,To)fromMontreal:\xef\xbf\xbd Datalog:\xef\xbf\xbd fromMontreal(C) \xe2\x86\x90\xe2\x86\x90\xe2\x86\x90\xe2\x86\x90 trainSchedule(\xe2\x80\x98Montreal\xe2\x80\x99, C).\xef\xbf\xbd Find every cities that can be reached from Montreal by trainTorontoNYCCalgaryBostonAlbanyQuebec City\xef\xbf\xbd fromMontreal(TC) \xe2\x86\x90\xe2\x86\x90\xe2\x86\x90\xe2\x86\x90 fromMontreal(C), trainSchedule(C,TC).Evaluation of Recursive RulesStart IDB = \xe2\x88\x85\xe2\x88\x85\xe2\x88\x85\xe2\x88\x85Apply rules w.r.t  IDB & EDByesnodoneChangeto IDB?ExampleInstance: Movie SequelStar wars Star wars IINaked Gun Naked Gun 2 Naked Gun 2 Naked Gun 2 \xc2\xbd Star wars II Star wars III Naked Gun 2 \xc2\xbd Naked Gun 3 Relation Schema: sequelOf(Movie,Sequel)For a given movie, find all the follow-up movies, i.e., a sequel, a sequel of a sequel, and so onExampleInstance: Movie SequelStar wars Star wars IINaked Gun Naked Gun 2 Naked Gun 2 Naked Gun 2 \xc2\xbd Star wars II Star wars III Naked Gun 2 \xc2\xbd Naked Gun 3 Relation Schema: sequelOf(Movie, Sequel)followUp(X, Y) \xe2\x86\x90\xe2\x86\x90\xe2\x86\x90\xe2\x86\x90 sequelOf(X,Y).followUp(X, Y) \xe2\x86\x90\xe2\x86\x90\xe2\x86\x90\xe2\x86\x90 sequelOf(X,Z), followUp(Z,Y).5Recursion\xef\xbf\xbd Let P be any datalog program\xef\xbf\xbd We say an IDB predicate r in P depends on predicate s if there is a rule in P with r as the head and s as a subgoal in the rule body\xef\xbf\xbd Construct the (dependency) graph of P:\xef\xbf\xbd Nodes -- IDB predicates in P\xef\xbf\xbd Arcs -- an arc from node r to s if r depends on s\xef\xbf\xbd Label the arc with \xe2\x80\x98\xc2\xac\xc2\xac\xc2\xac\xc2\xac\xe2\x80\x98 for negated subgoals\xef\xbf\xbd P is recursive iff its dependency graph has a cycleExamplefollowUpfollowUp(X, Y) \xe2\x86\x90\xe2\x86\x90\xe2\x86\x90\xe2\x86\x90 sequelOf(X,Y).followUp(X, Y) \xe2\x86\x90\xe2\x86\x90\xe2\x86\x90\xe2\x86\x90 sequelOf(X,Z), followUp(Z, Y).Safety\xef\xbf\xbd It is possible to write a rule that makes \xe2\x80\x9cno sense\xe2\x80\x9d.\xef\xbf\xbd Example of such rules:\xef\xbf\xbd s(X) \xe2\x86\x90 r(Y).\xef\xbf\xbd s(X) \xe2\x86\x90 NOT r(X).\xef\xbf\xbd s(X) \xe2\x86\x90 r(Y), X < Y.\xef\xbf\xbd In each of these rules, the IDB relation s (output relation) could be infinite, even if (the input) relation r is finite\xef\xbf\xbd Such rules are said to be not SAFESafety\xef\xbf\xbd For a rule to be safe, the following conditions must hold:\xef\xbf\xbd If a variable X appears in the rule head, then X must appear in an \xe2\x80\x9cordinary\xe2\x80\x9d predicate in the body or be equal to such a variable (directly or indirectly), e.g., X=Y, and Y appears in an ordinary predicate in the rule body.Recall: the predicates could be ordinary or built-in.'