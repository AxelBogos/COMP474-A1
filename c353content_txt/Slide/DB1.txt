b'\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDatabases\n\n\n                                 Concordia University \n\n               Computer Science and Software Engineering \n\n                                COMP353: Databases  \n\n                                    Winter 2020-2021 (REMOTE) \n\n \n\n \n\nInstructor:    Khaled Jababo (jababo@cse.concordia.ca) \n\nLectures:     Mo-We  10:15 \xe2\x80\x93 11:30 Online \n\nOffice hour: We   11:30 \xe2\x80\x93 12:30 Online \n\n \n\nmailto:jababo@cse.concordia.ca\n\n\n2 \n\nIntroduction to \n\nDatabases and SQL \n\n \n\n\n\nWhat is a Database?  \n\n \n\n\xef\x81\xae A database is a collection of data that exists over a \n\nlong period of time (Persistent storage) \n\n\xef\x81\xae This collection should be logically coherent and \n\nhave some inherent meaning, typically about an \n\nenterprise \xef\x83\xa8 it may not be a random pile of data \n\n \n\n3 \n\n\n\nExamples of Databases  \n\n\xef\x81\xae List of names, addresses, and phone numbers of \n\nyour friends \n\n\xef\x81\xae Information about employees, departments, \n\nsalaries, managers, etc. in a COMPANY \n\n\xef\x81\xae Information about students, courses, grades, \n\nprofessors, etc. in a UNIVERSITY \n\n\xef\x81\xae Information about books, users, etc. in a LIBRARY \n\n4 \n\n\n\nDatabase Management System (DBMS)  \n\n\xef\x81\xae A DBMS is a complex software package developed \n\nto store and \xe2\x80\x9cmanage\xe2\x80\x9d databases \n\n\xef\x81\xae Note the distinction between DB, DBS, and DBMS: \n\n   Database system = Database + DBMS  \n\n5 \n\n\n\nWhat does a DBMS provide?  \n\n\xef\x81\xae Supports convenient, efficient, and secure access and \nmanipulation of large amounts of data \n\n\xef\x81\xae (high-level) Programming interface: Gives users the ability to \ncreate, query, and modify the data \n\n\xef\x81\xae Persistent storage: Supports the storage of data over a long \nperiod of time  \n\n\xef\x81\xae Transaction management and recovery: Controls access to \nshared data from multiple, simultaneous users with properties \nAtomicity, Consistency, Isolation, Durability (ACID) \n\n6 \n\n\n\nFile Processing Systems (FPS) \n\n \nCustomer  \n\nMaster \nFile \n\nOS \nCustomer list \n\nUser 1 \nApplication \n\nProgram 1 \n\nPLI Cust-No \nCust-Name \nAddress \nCredit-Code \nDescription \n\n \nInvoice  \nMaster \n\nFile \n\nOS \nMonthly invoice \n\nUser 2 \nApplication \n\nProgram 2 \n\nCOBOL \nCust-No \nCust-Name \nAddress \nPart-No \nQty-Ordered \nPrice \n\nPart-No \nPart-Descr \nVendor-No \nQty-In-Stock \nQty-On-Order \n\n \nInventory  \n\nMaster \nFile \n\nOS \nParts list \n\nUser 3 \nApplication \n\nProgram 3 \n\nPASCAL \n\n7 \n\n\n\nDisadvantages of FPS \n\n\xef\x81\xae Redundancy of data: Identical data are distributed \nover various files \xe2\x80\x93 a major source of problems  \n\n\xef\x81\xae Waste of storage space: When the same field is stored \nin several files, the required storage space is needlessly \nhigh \xef\x83\xa8 high storage cost  \n\n\xef\x81\xae Multiple updates: One field may be updated in one file \nbut not in others \xef\x83\xa8 inconsistency and lack of data \nintegrity and hence potential conflicting reports \n\n\xef\x81\xae Multiple programming languages: Dealing with several \nprogramming languages which are often not user \nfriendly \xef\x83\xa8 high system maintenance cost \n\n8 \n\n\n\nDatabase Systems \n\n \nDatabase  \n\n \n\nCustomer list \n\nUser 1 \n\nMonthly invoice \n\nUser 2 \n\nParts list \n\nUser 3 \n\nOS \n\nData Items : \nCust-No \nCust-Name \nAddress \nCredit-Code \nDescription \nPart-No \n\nQty-Orderd \nPrice \nPart-descr \nVendor-No \nQty-In-Stock \nQty-On-Order \n\nQuery  \n\nLanguage \n\nDBMS \n\nRoutines \n\nData  \nManipulation \n\nLanguage \n\n9 \n\n\n\nAdvantages of Databases \n\n\xef\x81\xae Minimize data redundancy and avoid inconsistency \n\n    They provide:  \n\n\xef\x81\xae Concurrent access to shared data \n\n\xef\x81\xae Centralized control over data management \n\n\xef\x81\xae Security and authorization \n\n\xef\x81\xae Integrity and reliability \n\n\xef\x81\xae Data abstraction and independence \n\n10 \n\n\n\nAspects of Database Studies \n\n\xef\x81\xaeModeling and design of databases \xef\x83\xbc \n\n\xef\x81\xae Database programming \xef\x83\xbc \n\n\xef\x81\xae DBMS implementation \n\n   The first two aspects are studied in COMP 353  \n\n    The third one is studied in COMP 451 \n\n \n\n11 \n\n\n\nWhat is this course about?  \n\n\xef\x81\xae A database is a \xe2\x80\x9ccollection of data.\xe2\x80\x9d This data is managed \n\nby a DBMS \n\n\xef\x81\xae  Databases are essential today to support commercial, \n\nengineering, and scientific applications.   \n\n\xef\x81\xae They are at the core of many scientific investigations.  \n\n\xef\x81\xae Their power comes from a rich body of knowledge and \n\ntechnology developed over several decades \n\n\xef\x81\xae In this course, we study fundamental concepts, techniques, \n\nand tools for database design and programming. \n\n\xef\x81\xae In COMP451, we study details of DB implementation \n12 \n\n\n\nA  quick test! \n\n\xef\x81\xae Which one of the following is the main source of \n\nthe problems in file processing systems, addressed \n\nby databases? \n\nA. Waste of storage space. \n\nB. Update anomalies, which result in lack of data integrity. \n\nC. Data redundancy. \n\nD. Data inconsistency. \n\n13 \n\n\n\nData Modeling and  \n\nDatabase Design \n\nAn Overview \n\n14 \n\n\n\nTypes of Data Models \n\n\xef\x81\xae  A Data Model is a collection of concepts, describing  \n\n\xef\x81\xae data and relationships among data  \n\n\xef\x81\xae data semantics and data constraints \n\n\xef\x81\xae Entity-Relationship (ER) Model \xef\x83\x96  \n\n\xef\x81\xae Relational Model \xef\x83\x96 \n\n\xef\x81\xae Object-Oriented Data Model (ODL) \xef\x83\x96  \n\n\xef\x81\xae Logical Data Model (Datalog) \xef\x83\x96  \n\n\xef\x81\xae  Earlier \xe2\x80\x9crecord\xe2\x80\x9d based Data Models \n\n\xef\x81\xae Network \n\n\xef\x81\xae Hierarchical  15 \n\n\n\nRelational Model \n\n\xef\x81\xae Data is organized in relations (tables) \n\n   The user should/need not be concerned with the \n\nunderlying storage data structure. \n\n\xef\x81\xae Relational database schema:  \n\n\xef\x81\xae Set of table names \xe2\x80\x93  D = {R1,\xe2\x80\xa6,Rn} \n\n\xef\x81\xae Set of attributes for each table \xe2\x80\x93  Ri = {A1,\xe2\x80\xa6,Ak} \n\n\xef\x81\xae Examples of tables:  \n\n\xef\x81\xae Account=  {accNum, branchNam, amount, customerId} \n\n\xef\x81\xae Movie= {title, year, director, studio} 16 \n\n\n\nRelational Model  \n\n\xef\x81\xae Most widely used model \n\n\xef\x81\xae Vendors: Oracle, IBM, Informix, Microsoft, Sybase, etc. \n\n\xef\x81\xae Competitor: object-oriented model  \n\n\xef\x81\xae ObjectStore, Postgres, etc.  \n\n\xef\x81\xae Another approach: object-relational model \n\n17 \n\n\n\nObjectives of Database Systems \n\n \n\n\xef\x81\xae A DB system should be simple, so that many users with \nlittle skills could interact with the system  conveniently \n\n\xef\x81\xae It should be complex, so that many (complex) queries and \ntransactions could be handled/processed efficiently  \n\nBut these objectives are contradictory! \nSo how to achieve both? \n\n18 \n\n\n\nThree Views of Data \nEmployee name \n\nEmployee address \n\nSIN \n\nAnnual salary \n\nEmployee name: string    \n\nSIN: dec, key \n\nEmployee address: string \n\nEmployee health card No: string, unique \n\nAnnual salary: float \n\nEmployee name: string length 25 offset 0         \n\nSIN: 9 dec offset 25 unique \n\nEmployee health card No: string length 10 offset 34  unique \n\nEmployee address: string length 51 offset 44 \n\nAnnual salary: 9,2 dec offset 95 \n\nExternal view \n\nConceptual view \n\nInternal view \n\nUser 1 \n\nDatabase Administrator (DBA) \n\nUser 2 \n\n19 \n\n\n\nThree Views / Levels of Data \n\n\xef\x81\xae Internal  (physical) level \nA block of consecutive bytes actually holding the data \n\n\xef\x81\xae  Conceptual (logical) level \ntype emp = record \n\n SIN : integer; \n\n name : string; \n\n address : string; \n\n salary : real; \n\n healthCard  : string; \n\nend  \n\n\xef\x81\xae External (logical) level \nView 1 : (emp.name, emp.address) \n\nView 2 : (emp.SIN, emp.salary) 20 \n\n\n\nLevels of Abstraction in DB\xe2\x80\x99s \n\n\xef\x81\xae Views describe how users \n\n\xe2\x80\x9csee\xe2\x80\x9d the data \n\n\xef\x81\xae Conceptual schema \n\ndefines logical structure \n\n\xef\x81\xae Physical schema \n\ndescribes the storage \n\nstructure of data and the \n\nindexes  \n\nView 1 View 2 View 3 \n\nConceptual Schema  \n\nPhysical Schema  \n\nAbstraction is achieved through describing each level in terms of a schema using a \n\nparticular data model 21 \n\n\n\nSchemas at different levels of \n\nabstraction \n\n\xef\x81\xae View (or External users): are typically determined during \n\nrequirements analysis (often defined as views over some \n\nof the concepts in the logical DB schema) \n\n\xef\x81\xae Conceptual (or Logical) Schema: an outcome of a \n\ndatabase design (a main focus in this course) \n\n\xef\x81\xae Physical Schema: storage and index structures associated \n\nwith relations \n\n22 \n\n\n\nSchemas and Instances \n\n\xef\x81\xae A database instance is the current content of the DB \n\n\xef\x81\xae A database schema is the structure of the data \n\n(relations/classes), described in some suitable data model \ne.g. relation:     \n\n    Students {sid, name, department, dob, address}  rep. as a set  or \n\n    Students (sid, name, department, dob, address)  as a tuple  \n\n \n\nStudents  \n\nsid name department dob address \n\n1112223 John Smith CS 12-01-82 22 Pine, #1203 \n\n2223334 Ali  Brown EE 31-08-73 2000 St. Marc \n\n3334445 Sana Kordi  CS 23-11-79 1150 Guy  \n23 \n\n\n\nData Independence \n\xef\x81\xae Defn: the ability to modify definition of schema at one level \n\nwith little or no affect on the schema (s) at a higher level \n\xef\x81\xae Achieved through the use of three levels of data abstraction  \n\n\xef\x81\xae Logical Data Independence \n\xef\x81\xae Ability to modify logical schema with little or no affect/change to \n\nrewrite the application programs \n\n\xef\x81\xae E.g., adding new fields to a record or changing the type of a field \n\n\xef\x81\xae Physical Data Independence \n\xef\x81\xae Ability to modify physical schema with little or no  impact on the \n\nconceptual schema or the application programs, i.e., the \npossibility of having separate schemas at the physical and \nconceptual levels \n\n\xef\x81\xae E.g., changing a file structure from sequential to direct access 24 \n\n\n\nDBMS Implementation \n\nOverview \n\n25 \n\n\n\nQuery  \nProcessor \n\nSchema  \nModifications \n\nTransaction  \nManager \n\nStorage  \nManager \n\nData \n\nMetadata \n\nQueries \n\nTransactions \n\nArchitecture of a DBMS \n\n\xef\x81\xae There are 3 types of inputs \n\nto DBMS: \n\n\xef\x81\xae Queries \n\n\xef\x81\xae Transactions, i.e.,  \n\n     data Modifications \n\n\xef\x81\xae Schema Creations/ \n\nModifications \n\n26 \n\n\n\nArchitecture of a DBMS \n\n\xef\x81\xae The query processor \nhandles: \n\xef\x81\xae Queries \n\n\xef\x81\xae Modifications (of both \ndata and schema) \n\n\xef\x81\xae The job of the query \nprocessor + query \noptimizer (QO) is \n\xef\x81\xae To find the \xe2\x80\x9cbest\xe2\x80\x9d plan to \n\nprocess the query \n\n\xef\x81\xae To issue commands to \nstorage/buffer manager \n\nQuery  \nProcessor \n\nSchema  \nModifications \n\nTransaction  \nManager \n\nStorage  \nManager \n\nData \n\nMetadata \n\nQueries \n\nModifications \n\n27 \n\n\n\nArchitecture of a DBMS \n\n\xef\x81\xae The job of the storage \n\nmanager is  \n\n\xef\x81\xae To obtain information \n\nrequested from the \n\ndata storage \n\n\xef\x81\xae To modify the \n\ninformation to the data \n\nstorage when \n\nrequested. \n\nQuery  \nProcessor \n\nSchema  \nModifications \n\nTransaction  \nManager \n\nStorage  \nManager \n\nData \n\nMetadata \n\nQueries \n\nModifications \n\n28 \n\n\n\nArchitecture of a DBMS \n\n\xef\x81\xae The transaction manager \n\nis responsible for the \n\nconsistency of the data  \n\n\xef\x81\xae The job of the transaction \n\nmanager is to ensure: \n\n\xef\x81\xae several queries running \n\nsimultaneously do not \n\n\xe2\x80\x9cinterfere\xe2\x80\x9d with each other  \n\n\xef\x81\xae Integrity of the data data \n\neven if there is a power \n\nfailure (Recovery system) \n\nQuery  \nProcessor \n\nSchema  \nModifications \n\nTransaction  \nManager \n\nStorage  \nManager \n\nData \n\nMetadata \n\nQueries \n\nModifications \n\n29 \n\n\n\nArchitecture of a DBMS \n\n\xef\x81\xae A representation of data \n\nand other relevant \n\ninformation on disk  \n\n\xef\x81\xae It contains: \n\n\xef\x81\xae Data \n\n\xef\x81\xae Metadata \n\nQuery  \nProcessor \n\nSchema  \nModifications \n\nTransaction  \nManager \n\nStorage  \nManager \n\nData + \n\nMetadata \n\nQueries \n\nModifications \n\n30 \n\n\n\nUsers of a Database System \n\nDBMS and  \nits data manager \n\nQuery  \nprocessor \n\nOS or own \nfile manager \n\nDDL compiler \n\nCompiled \n\napplication \n\nprogram \n\n \n \n \n\nData + MetaData \n+ Indexes \n\nOS disk \nmanager \n\nCompiled \n\nuser interface \n\nTelecom system \n\nTelecom system \nTelecom system \n\nNaive user \n\nApplication developer \n\nDBA \n\nSpecialized user \n\n31 \n\n\n\nDatabase Programming \n\nOverview \n\n32 \n\n\n\nDatabase Languages \n\n\xef\x81\xae A Database Management System (DBMS) \n\nprovides two types of languages, which may also \n\n    be viewed as components of the DBMS language: \n\n\xef\x81\xae Data Definition Language (DDL) \n\n\xe2\x80\xa2 Language (notation) for defining a database schema  \n\n\xe2\x80\xa2 It includes syntax for declaring tables, indexes, views, \n\nconstraints, etc.) \n\n\xef\x81\xae Data Manipulation Language (DML) \n\n\xe2\x80\xa2 Language for accessing and manipulating the data \n\n(organized/stored according to the appropriate data model) \n33 \n\n\n\nQuery Languages \n\n\xef\x81\xae Commercial: \n\n\xef\x81\xae SQL\xef\x83\x96 \n\n\xef\x81\xae Theoretical/Abstract: \n\n\xef\x81\xae Relational Algebra \xef\x83\x96 \n\n\xef\x81\xae Relational Calculus \n\n\xef\x81\xae Datalog \xef\x83\x96 \n\n \n\n34 \n\n\n\nSQL  \n\n\xef\x81\xae Developed originally at IBM in 1976 \n\n\xef\x81\xae First standard: SQL-86  \n\n\xef\x81\xae Second standard: SQL-92  \n\n\xef\x81\xae Other standards: SQL-99, or SQL3, well over 1,000 page doc. \n\n\xef\x81\xae Currently SQL-2019 which supports MultiDim. Arrays \n\n\xef\x81\xae De-facto standard of the relational database world; \n\nreplaced all other DB languages  \n\n\xef\x81\xae The SQL query language components: \n\n\xef\x81\xae DDL \n\n\xef\x81\xae DML \n35 \n\n\n\nSimple SQL Queries \n\n\xef\x81\xae A SQL query has a form:  \nSELECT . . . \n\nFROM . . . \n\nWHERE . . . ; \n\n\xef\x81\xae The SELECT clause indicates which attributes should \nappear in the output. \n\n\xef\x81\xae The FROM gives the relation(s) the query refers to \n\n\xef\x81\xae The WHERE clause is a Boolean expression indicating \nwhich tuples are of interest. \n\n\xef\x81\xae A query result is a bag, in general \n\n\xef\x81\xae A query result is unnamed. \n36 \n\n\n\nExample SQL Query  \n\n\xef\x81\xae Relation schema: \n\nCourse (courseNumber, name, noOfCredits) \n\n\xef\x81\xae Query: \n\nFind all the courses stored in the database \n\n\xef\x81\xae Query in SQL: \n\nSELECT \xef\x80\xaa \n\nFROM Course;  \n\n \n\nNote: \xe2\x80\x9c \xef\x80\xaa \xe2\x80\x9c means all attributes in the relation(s) involved. \n\n37 \n\n\n\nExample SQL Query  \n\n\xef\x81\xae Relation schema: \n\nMovie (title, year, length, filmType) \n\n\xef\x81\xae Query: \n\nFind the titles of all movies stored in the database \n\n\xef\x81\xae Query in SQL: \n\nSELECT title \n\nFROM Movie;  \n\n38 \n\n\n\nExample SQL Query  \n\n\xef\x81\xae Relation schema: \n\nStudent (ID, firstName, lastName, address, GPA) \n\n\xef\x81\xae Query: \n\nFind the ID of every student whose GPA is more than 3  \n\n\xef\x81\xae Query in SQL: \n\nSELECT ID \n\nFROM Student \n\nWHERE GPA > 3;  \n\n39 \n\n\n\nExample SQL Query  \n\n\xef\x81\xae Relation schema: \n\nStudent (ID, firstName, lastName, address, GPA) \n\n\xef\x81\xae Query: \n\nFind the ID and last name of every student with first name \xe2\x80\x99John\xe2\x80\x99, \n\n who has a GPA > 3  \n\n\xef\x81\xae Query in SQL: \n\nSELECT ID, lastName \n\nFROM Student \n\nWHERE firstName = \xe2\x80\x99John\xe2\x80\x99 AND GPA > 3;  \n\n40 \n\n\n\nWHERE clause \n\xef\x81\xae The expressions that may follow WHERE are conditions \n\n\xef\x81\xae Standard comparison operators \xce\x98 includes { =, <>, <, >, <=, >= } \n\n\xef\x81\xae The values that may be compared include constants and \nattributes of the relation(s) mentioned in FROM clause \n\n\xe2\x80\xa2 Simple expression \n\n\xe2\x80\xa2 A op Value \n\n\xe2\x80\xa2 A op B \n\nwhere A, B are attributes and op is a comparison operator  \n\n\xef\x81\xae We may also apply the usual arithmetic operators, +,-,*,/, etc. to \nnumeric values before comparing them  \n\n\xe2\x80\xa2 (year - 1930) * (year - 1930) \xef\x80\xbc 100 \n\n\xef\x81\xae The result of a comparison is a Boolean value, TRUE or FALSE  \n\n\xef\x81\xae Boolean expressions can be combined by the logical operators \nAND, OR, and NOT  41 \n\n\n\nExample SQL Query  \n\n\xef\x81\xae Relation schema: \n\nMovie (title, year, length, filmType) \n\n\xef\x81\xae Query: \n\nFind the titles of all color movies produced in 1990 \n\n\xef\x81\xae Query in SQL: \n\nSELECT title \n\nFROM Movie \n\nWHERE filmType = \xe2\x80\x99color\xe2\x80\x99 AND year = 1990;  \n\n42 \n\n\n\nExample SQL Query  \n\n\xef\x81\xae Relation schema: \nMovie (title, year, length, filmType) \n\n\xef\x81\xae Query: \n Find the titles of color movies that are either made after 1970 or \n\n are less than 90 minutes long \n\n\xef\x81\xae Query in SQL: \nSELECT title \n\nFROM Movie \n\nWHERE (year > 1970 OR length < 90) AND filmType = \xe2\x80\x99color\xe2\x80\x99;  \n\n\xef\x81\xae Note the precedence rules, when parentheses are absent: \nAND takes precedence over OR, and  \n\nNOT takes precedence over AND and OR 43 \n\n\n\nProducts and Joins  \n\n\xef\x81\xae SQL has a simple way to \xe2\x80\x9ccouple\xe2\x80\x9d relations in one query \n\n\xef\x81\xae How? By \xe2\x80\x9clisting\xe2\x80\x9d the relevant relation(s) in the FROM clause \n\n \n\n\xef\x81\xae All the relations in the FROM clause are coupled through \n\nCartesian product (shown as \xef\x82\xb4 in algebra notation) \n\n44 \n\n\n\nCartesian Product \n\n\xef\x81\xae From Set Theory: \n\n\xef\x81\xae The Cartesian Product of two sets R and S is the \n\nset of all pairs (a, b) such that: a \xe2\x88\x88 R and b \xe2\x88\x88 S. \n\n\xef\x81\xae Denoted as R \xef\x82\xb4 S  \n\n\xef\x81\xae Note: \n\n\xe2\x80\xa2 In general, R \xef\x82\xb4 S \xef\x82\xb9 S \xef\x82\xb4 R \n\n45 \n\n\n\nA  quick test! \n\n\xef\x81\xae Let R(A1,\xe2\x80\xa6,An) be a relation schema and r be any \n\ninstance of R. Suppose r has m tuples. Which of \n\nthe following is the number of ways in which r may \n\nbe represented in the relational model?  \n\nA. m * n  \n\nB. 2m  \n\nC. m! * n! \n\nD. 2n \n\n \n46 \n\n\n\nExample \nInstance S: Instance R: \n\nR x S: \n\nB C D \n\n2 5 6 \n\n4 7 8 \n\n9 10 11 \n\nA B \n\n1 2 \n\n3 4 \n\nA R.B S.B C D \n\n1 2 2 5 6 \n\n1 2 4 7 8 \n\n1 2 9 10 11 \n\n3 4 2 5 6 \n\n3 4 4 7 8 \n\n3 4 9 10 11 47 \n\n\n\nExample \nInstance of Course: Instance of Student: \n\nSELECT \xef\x80\xaa FROM Student, Course; \nID firstName lastName GPA Address courseNumber name noOfCredits \n\n111 Joe Smith 4.0 45 Pine av. Comp352 Data structures 3 \n\n111 Joe Smith 4.0 45 Pine av. Comp353 Databases 4 \n\n222 Sue Brown 3.1 71 Main st. Comp352 Data structures 3 \n\n222 Sue Brown 3.1 71 Main st. Comp353 Databases 4 \n\n333 Ann Johns 3.7 39 Bay st.  Comp352 Data structures 3 \n\n333 Ann Johns 3.7 39 Bay st.  Comp353 Databases 4 \n\nID firstName lastName GPA Address \n\n111 Joe Smith 4.0 45 Pine av. \n\n222 Sue Brown 3.1 71 Main st. \n\n333 Ann Johns 3.7 39 Bay st.  \n\ncourseNumber name noOfCredits \n\nComp352 Data structures 3 \n\nComp353 Databases 4 \n\n48 \n\n\n\nExample \nInstance of Course: Instance of Student: \n\nSELECT ID, courseNumber  \n\nFROM Student, Course; \n\nID firstName lastName GPA Address \n\n111 Joe Smith 4.0 45 Pine av. \n\n222 Sue Brown 3.1 71 Main st. \n\n333 Ann Johns 3.7 39 Bay st.  \n\ncourseNumber name noOfCredits \n\nComp352 Data structures 3 \n\nComp353 Databases 4 \n\nID courseNumber \n\n111 Comp352 \n\n111 Comp353 \n\n222 Comp352 \n\n222 Comp353 \n\n333 Comp352 \n\n333 Comp353 \n49 \n\n\n\nExample \n\n\xef\x81\xae Relation schemas: \n\nStudent (ID, firstName, lastName, address, GPA) \n\nUgrad (ID, major) \n\n\xef\x81\xae Query:  \n\nFind \xe2\x80\x9call\xe2\x80\x9d information about every undergraduate student \n\n\xef\x81\xae We try first by computing the Cartesian product (\xef\x82\xb4) \n\nSELECT \xef\x80\xaa FROM Student, Ugrad; \n\n50 \n\n\n\nExample \nInstance of Ugrad: Instance of Student: \n\nSELECT \xef\x80\xaa FROM Student, Ugrad; \nID firstName lastName GPA Address ID major \n\n111 Joe Smith 4.0 45 Pine av. 111 CS \n\n111 Joe Smith 4.0 45 Pine av. 333 EE \n\n222 Sue Brown 3.1 71 Main st. 111 CS \n\n222 Sue Brown 3.1 71 Main st. 333 EE \n\n333 Ann Johns 3.7 39 Bay st.  111 CS \n\n333 Ann Johns 3.7 39 Bay st.  333 EE \n\nID firstName lastName GPA Address \n\n111 Joe Smith 4.0 45 Pine av. \n\n222 Sue Brown 3.1 71 Main st. \n\n333 Ann Johns 3.7 39 Bay st.  \n\nID major \n\n111 CS \n\n333 EE \n\nOnly the green tuples \n\nshould be in the query \n\nresult. How to pick \n\nthem only? \n51 \n\n\n\nExample \nInstance of Ugrad: Instance of Student: \n\nSELECT \xef\x80\xaa  \nFROM Student, Ugrad  \n\nWHERE Student.ID = Ugrad.ID; \n\nID firstName lastName GPA Address ID major \n\n111 Joe Smith 4.0 45 Pine av. 111 CS \n\n333 Ann Johns 3.7 39 Bay st.  333 EE \n\nID firstName lastName GPA Address \n\n111 Joe Smith 4.0 45 Pine av. \n\n222 Sue Brown 3.1 71 Main st. \n\n333 Ann Johns 3.7 39 Bay st.  \n\nID major \n\n111 CS \n\n333 EE \n\n52 \n\n\n\nJoin in SQL \n\n\xef\x81\xae The above query is an example of Join operation \n\n\xef\x81\xae There are different kinds of joins, which we will studyl \n\n\xef\x81\xae To join relations R1,\xe2\x80\xa6,Rn in SQL:  \n\n\xef\x81\xae List all these relations in the FROM clause \n\n\xef\x81\xae Express the conditions in the WHERE clause in order to get the \n\n\xe2\x80\x9cdesired\xe2\x80\x9d  join \n\n53 \n\n\n\nJoining Relations  \n\n\xef\x81\xae Relation schemas: \n\nMovie (title, year, length, filmType) \n\nOwns (title, year, studioName) \n\n\xef\x81\xae Query: Find title, length, and studio name of every movie  \n\n\xef\x81\xae Query in SQL: \n\nSELECT Movie.title, Movie.length, Owns.studioName  \n\nFROM Movie, Owns \n\nWHERE Movie.title = Owns.title AND Movie.year = Owns.year; \n\n \n\nQuestion: Is Owns in Owns.studioName necessary?  \n\n \n54 \n\n\n\nJoining Relations  \n\n\xef\x81\xae Relation schemas: \nMovie (title, year, length, filmType) \n\nOwns (title, year, studioName) \n\n\xef\x81\xae Query: \n\n    Find the title and length of every movie produced by \nDisney studio. \n\n\xef\x81\xae Query in SQL: \nSELECT Movie.title, length \n\nFROM Movie, Owns \n\nWHERE Movie.title = Owns.title AND  \n\n              Movie.year = Owns.year AND studioName = \xe2\x80\x99Disney\xe2\x80\x99;  \n55 \n\n\n\nJoining Relations  \n\xef\x81\xae Relation schemas: \n\nMovie (title, year, length, filmType) \n\nOwns (title, year, studioName)  \n\nStarsIn (title, year, starName) \n\n\xef\x81\xae Query: \nFind the title and length of Disney movies with JR as an actress. \n\n \n\n\xef\x81\xae Query in SQL: \nSELECT Movie.title, Movie.length \n\nFROM Movie, Owns, StarsIn \n\nWHERE Movie.title = Owns.title AND Movie.year = Owns.year   \nAND Movie.title = StarsIn.title AND Movie.year = StarsIn.year \nAND studioName = \xe2\x80\x99Disney\xe2\x80\x99 AND starName = \xe2\x80\x98JR\xe2\x80\x99;  \n\n\n\nExample \n\ntitle year starName \n\nT1 1990 JR \n\nT2 1991 JR \n\ntitle year studioName \n\nT1 1990 Disney \n\nT2 1991 MGM \n\ntitle year length filmType \n\nT1 1990 124 color \n\nT2 1991 144 color \n\nSELECT Movie.title, Movie.length \n\nFROM Movie, Owns, StarsIn \n\nWHERE Movie.title = Owns.title AND Movie.year = \nOwns.year AND  Movie.title = StarsIn.title AND \nMovie.year = StarsIn.year AND studioName = \xe2\x80\x99Disney\xe2\x80\x99 \nAND starName = \xe2\x80\x99JR\xe2\x80\x99;  \n\ntitle length \n\nT1 124 \n\nMovie Owns \n\nStarsIn \n\n57 \n\n\n\nAggregation in SQL \n\n\xef\x81\xae SQL provides 5 operators that can be applied to a \n\ncolumn of a relation in order to produce some kind of \n\n\xe2\x80\x9csummary\xe2\x80\x9d  \n\n\xef\x81\xae These operators are called aggregations \n\n\xef\x81\xae They are used in a SELECT clause and often applied \n\nto a scalar-valued attribute (column) or an expression \n\nin general. \n\n58 \n\n\n\nAggregation Operators \n\xef\x81\xae SUM \n\n\xef\x81\xae Returnes the sum of values in the column \n\n\xef\x81\xae AVG \n\n\xef\x81\xae Returns the average of values in the column \n\n\xef\x81\xae MIN \n\n\xef\x81\xae Returns the least value in the column \n\n\xef\x81\xae MAX \n\n\xef\x81\xae Returns the greatest value in the column \n\n\xef\x81\xae COUNT \n\n\xef\x81\xae Returns the number of values in the column, including the \n\nduplicates, unless the keyword DISTINCT is used explicitly 59 \n\n\n\nExample \n\n\xef\x81\xae Relation schema: \n\nExec(name, address, cert#, netWorth) \n\n\xef\x81\xae Query: \n\nFind the average net worth of the movie executives \n\n\xef\x81\xae Query in SQL: \n\nSELECT AVG(netWorth) \n\nFROM Exec; \n\n\xef\x81\xae The sum of \xe2\x80\x9call\xe2\x80\x9d values in the column netWorth divided by \nthe number of these values \n\n\xef\x81\xae In general, if a value v appears n times in the column, it \ncontributes the value n*v to computing the average \n\n60 \n\n\n\nExample \n\n\xef\x81\xae Relation schema: \nExec (name, address, cert#, netWorth) \n\n\xef\x81\xae Query: \nHow many movie executives are there in the Exec relation? \n\n\xef\x81\xae Query in SQL: \nSELECT COUNT(*) \n\nFROM Exec; \n\n\xef\x81\xae The use of * as a parameter is unique to COUNT; \n\n      Its use for other aggregation operations makes no sense. \n\n61 \n\n\n\nExample \n\n\xef\x81\xae Relation schema: \nExec (name, address,  cert#,  netWorth) \n\n\xef\x81\xae Query: \nHow many different names are there in the Exec relation? \n\n\xef\x81\xae Query in SQL: \nSELECT COUNT (DISTINCT name) \n\nFROM Exec; \n\n\xef\x81\xae In query processing time, the system first eliminates the duplicates \n\nfrom the column name, and then counts the number of present \n\nvalues \n\n62 \n\n\n\nAggregation -- Grouping \n\n\xef\x81\xae To answer a query, we may need to \xe2\x80\x9cgroup\xe2\x80\x9cthe tuples \naccording to the values of some other column(s) \n\n\xef\x81\xae Example: Suppose we want to find: \n\n     Total length in minutes of movies produced by each studio: \n       Movie(title, year, length, filmType, studioName, producerC#) \n\n\xef\x81\xae We must group the tuples in the Movie relation according to \ntheir studio, and then find the sum of the lengths within each \ngroup. The result displayed would look like: \n\nstudio  SUM(length) \n\nDisney  12345 \n\nMGM  54321 \n\xe2\x80\xa6  \xe2\x80\xa6 \n\n  \n\n63 \n\n\n\nAggregation - Grouping \n\n\xef\x81\xae Relation schema: \nMovie(title, year, length, filmType, studioName, producerC#) \n\n\xef\x81\xae Query: What is the total length in minutes produced by each studio? \n\n\xef\x81\xae Query formulated/expressed in SQL: \nSELECT studioName, SUM(length) \n\nFROM Movie \n\nGROUP BY studioName; \n\n\xef\x81\xae Whatever aggregation used in the SELECT clause will be applied \nonly within groups  \n\n\xef\x81\xae Only those attributes mentioned in the GROUP BY clause may \nappear unaggregated in the SELECT clause \n\n\xef\x81\xae Can we use GROUP BY without using aggregation? 64 \n\n\n\nAggregation -- Grouping \n\n\xef\x81\xae Relation schema: \nMovie(title, year, length, filmType, studioName, producerC#) \n\nExec(name, address, cert#, netWorth) \n\n\xef\x81\xae Query: \nFor each producer (name), list the total length of the films produced \n\n\xef\x81\xae Query in SQL: \nSELECT Exec.name, SUM(Movie.length) \n\nFROM Exec, Movie \n\nWHERE Movie.producerC# = Exec.cert# \n\nGROUP BY Exec.name; \n\n65 \n\n\n\nA rule about null values! \n\n\xef\x81\xae Nulls are counted when grouping but ignored when \naggregating. \n\n    Example: Consider the instance below of R(A,B).  \n\n    Which one of the following tuples will not be in the output?                  \n\n                                                                     A    B \n    Select A, Sum(B)                                   null  1  \n\n    From R                                                   2      1 \n\n    Group By A;                                          null   null \n\n                                                                    3       2 \n\nA. (null, null)                                                      2        3 \n\nB. (2,4)                                                              1        null  \n\nC. (1,null)  \n\nD. (null,1) \n\n \n\n66 \n\n\n\nA rule about null values! \n\n\xef\x81\xae The answer:                   \n\n                                                                     A    B \n    Select A, Sum(B)                                   null  1  \n\n    From R                                                   2      1 \n\n    Group By A;                                          null   null \n\n                                                                    3       2 \n\n\xe2\x88\x9a  (null, null)                                                      2        3 \n\n\xef\x81\xae (2,4)                                                              1        null  \n\n\xef\x81\xae (1,null)  \n\n\xef\x81\xae  (null,1) \n\n \n\n67 \n\n\n\nAnother test! \n\n\xef\x81\xae Consider again the same instance of R(A,B) containing the tuples: \n(null,1), (2,1),  (null, null), (3,2), (2,3), and (1,null). Which of the \nfollowing tuples will be in the result of the query below? \n\n \n    Select A, Sum(B)  \n\n    From R  \n\n    Where B<>2 \n\n    Group By A; \n\n \n\nA. (null, 0) \n\nB. (1,null)  \n\nC. (2,3)  \n\nD. (2,4) \n\n 68 \n\n\n\nAnswer! \n\n\xef\x81\xae Consider an instance of R(A,B) with the tuples (null,1), (2,1),  \n\n    (null, null), (3,2), (2,3), and (1,null). Which one of the following tuples \nwill be present in the result of the query below? \n    Select A, Sum(B)  \n\n    From R  \n\n    Where B<>2 \n\n    Group By A; \n\n \n\n\xef\x81\xae (null, 0)                                                              null  1 \n\n\xef\x81\xae (1,null)                                                                2     1 \n\n\xef\x81\xae (2,3)                                                                    2     3  \n\n\xe2\x88\x9a   (2,4) \n\n69 \n\n\n\nAggregation \xe2\x80\x93 HAVING clause \n\n\xef\x81\xae We might be interested in not every group but those which \n\nsatisfy certain conditions  \n\n\xef\x81\xae For this, after a GROUP BY clause use a HAVING clause  \n\n\xef\x81\xae HAVING is followed by some conditions about the group \n\n\xef\x81\xae We can not use a HAVING clause without GROUP BY \n\n70 \n\n\n\nAggregation \xe2\x80\x93 HAVING clause \n\n\xef\x81\xae Relation schema: \nMovie (title, year, length, filmType, studioName, producerC#) \n\nExec(name, address, cert#, netWorth) \n\n\xef\x81\xae Query: \nFor those producers who made at least one film prior to 1930, list the \n\n total length of the films produced \n\n\xef\x81\xae Query in SQL: \nSELECT Exec.name, SUM(Movie.length) \n\nFROM Exec, Movie \n\nWHERE producerC# = cert# \n\nGROUP BY Exec.name \n\nHAVING MIN(Movie.year) \xef\x80\xbc 1930; 71 \n\n\n\nAggregation \xe2\x80\x93 HAVING clause \n\xef\x81\xae This query chooses the group based on the property of each group \n\nSELECT Exec.name, SUM(Movie.length) \n\nFROM Exec, Movie \n\nWHERE producerC# = cert# \n\nGROUP BY Exec.name \n\nHAVING MIN(Movie.year) < 1930; \n\n \n\n\xef\x81\xae Consider the following query which chooses the movies based on the \nproperty of  each movie tuple: \n\n \n\nSELECT Exec.name, SUM(Movie.length) \n\nFROM Exec, Movie \n\nWHERE producerC# = cert# AND Movie.year < 1930 \n\nGROUP BY Exec.name; \n \n\n \n\n72 \n\n\n\nOrder By \n\xef\x81\xae The SQL statements/queries we looked at so far return an unordered \n\nrelation/bag. What if we want the result displayed in a certain order? \n\nMovie (title, year, length, filmType, studioName, producerC#) \n\n \n\nSELECT Exec.name, SUM(Movie.length) \n\nFROM Exec, Movie \n\nWHERE producerC# = cert# \n\nGROUP BY Exec.name \n\nHAVING MIN(Movie.year) < 1930 \n\nORDER BY Exec.name ASC; \n\n \nIn general: \n\nORDER BY A ASC, B DESC, C ASC; \n\n \n\n73 \n\n\n\nDatabase Modifications \n\xef\x81\xae SQL & Database Modifications? \n\n\xef\x81\xae We now look at SQL statements that do not return tuples,  \n\n    but rather change the state (content) of the database \n\n\xef\x81\xae There are three types of such statements/transactions: \n\n\xef\x81\xae Insert tuples into a relation \n\n\xef\x81\xae Delete certain tuples  from a relation \n\n\xef\x81\xae Update values of certain attributes of certain existing tuples \n\n    These types of operations that modify the database content are \n\nreferred  to as transactions \n\n74 \n\n\n\nInsertion \n\xef\x81\xae The insertion statement consists of: \n\n\xef\x81\xae The keyword INSERT INTO \n\n\xef\x81\xae The name of a relation R \n\n\xef\x81\xae A parenthesized list of attributes of the relation R \n\n\xef\x81\xae The keyword VALUES  \n\n\xef\x81\xae A tuple expression, that is, a parenthesized list of concrete values, \n\none for each attribute in the attribute list  \n\n\xef\x81\xae The form of an insert statement: \n\n INSERT INTO R(A1, \xe2\x80\xa6, An) VALUES (v1,\xe2\x80\xa6, vn) ; \n\n\xe2\x80\xa2 This command inserts the tuple (v1,...,vn) to table R, where vi  is \n\nthe value of attribute Ai , for  i = 1,\xe2\x80\xa6,n  75 \n\n\n\nInsertion \n\n\xef\x81\xae Relation schema: \nStarsIn (title, year, starName) \n\n\xef\x81\xae Update the database: \nAdd \xe2\x80\x9cSydney Greenstreet\xe2\x80\x9d to the list of stars of The Maltese Falcon \n\n\xef\x81\xae In SQL: \n\n INSERT INTO StarsIn (title,year, starName) \n\n VALUES(\xe2\x80\x99The Maltese Falcon\xe2\x80\x99, 1942, \xe2\x80\x99Sydney Greenstreet\xe2\x80\x99); \n\n     Another formulation of this query: \n\n     INSERT INTO StarsIn  \n\n VALUES(\xe2\x80\x99The Maltese Falcon\xe2\x80\x99, 1942, \xe2\x80\x99Sydney Greenstreet\xe2\x80\x99); \n\n \n\n76 \n\n\n\nInsertion \n\xef\x81\xae The previous insertion statement was \xe2\x80\x9csimple\xe2\x80\x9d in that it  \n\n     added one tuple only into a relation \n\n\xef\x81\xae Instead of using explicit values for a tuple in insertion, we can \n\nrequest  a set of tuples to be inserted. For this we define, in a \n\nsubquery,  the set of tuples from an existing relation \n\n\xef\x81\xae This subquery replaces the keyword VALUES and the tuple \n\nexpression in the INSERT statement \n\n77 \n\n\n\nInsertion \n\n\xef\x81\xae Database schema: \nStudio(name, address, presC#) \n\nMovie(title, year, length, filmType, studioName, producerC#) \n\n\xef\x81\xae Update the database: \n    Add to Studio, all studio names mentioned in the Movie relation \n\n\xef\x81\xae Note: If the list of attributes in an \xe2\x80\x9cinsert\xe2\x80\x9d statement does not \ninclude all the attributes of the relation, the tuple created will \nhave the default value for each missing attribute \n\n\xef\x81\xae Since there is no way to determine an address or a presC# \nfor a studio tuple, NULL will be used for these attributes. \n\n78 \n\n\n\nInsertion \n\n\xef\x81\xae Database schema: \nStudio(name, address, presC#) \n\nMovie(title, year, length, filmType, studioName, producerC#) \n\n\xef\x81\xae Update the database: \nAdd to Studio, all studio names mentioned in the Movie relation \n\n\xef\x81\xae In SQL: \n INSERT INTO Studio(name) \n\n SELECT DISTINCT studioName \n\n FROM Movie \n\n WHERE studioName NOT IN (SELECT name \n\n       FROM Studio);  \n79 \n\n\n\nDeletion \n\xef\x81\xae A delete statement consists of : \n\n\xef\x81\xae The keyword DELETE FROM \n\n\xef\x81\xae The name of a relation R \n\n\xef\x81\xae The keyword WHERE \n\n\xef\x81\xae A condition  \n\n\xef\x81\xae The syntax of the delete statement: \n\n DELETE FROM R WHERE \xef\x80\xbccondition\xef\x80\xbe; \n\n\xef\x81\xae The effect of executing this statement is that \xe2\x80\x9cevery tuple\xe2\x80\x9d in \n\nrelation R satisfying the condition will be deleted from R \n\n\xef\x81\xae Note: unlike the INSERT, we MAY need a WHERE clause here \n\n80 \n\n\n\nDeletion \n\n\xef\x81\xae Relation schema: \nStarsIn(title, year, starName) \n\n\xef\x81\xae Update: \nDelete the tuple that says:   \n\n    Sydney Greenstreet was a star in The Maltese Falcon \n\n\xef\x81\xae In SQL: \n DELETE FROM StarIn \n\n WHERE title = \xe2\x80\x99The Maltese Falcon\xe2\x80\x99 AND  \n\n                   starName = \xe2\x80\x99Sydney Greenstreet\xe2\x80\x99; \n\n81 \n\n\n\nDeletion \n\n\xef\x81\xae Relation schema: \nExec(name, address, cert#, netWorth) \n\n\xef\x81\xae Update: \nDelete every movie executive whose net worth is < $10,000,000 \n\n\xef\x81\xae In SQL: \n DELETE FROM Exec \n\n WHERE netWorth < 10,000,000; \n \n\n    Anything wrong here?! \n\n82 \n\n\n\nDeletion \n\n\xef\x81\xae Relation schema: \nStudio(name, address, presC#) \n\nMovie(title, year, length, filmType, studioName, producerC#) \n\n\xef\x81\xae Update: \nDelete from Studio, those studios not mentioned in Movie  \n\n    (i.e., we don\xe2\x80\x99t want to have non-productive studios!!)  \n\n\xef\x81\xae In SQL: \n DELETE FROM Studio \n\n WHERE name NOT IN (SELECT StudioName \n         FROM Movie);  \n\n83 \n\n\n\nUpdate \n\xef\x81\xae Update statement consists of: \n\n\xef\x81\xae The keyword UPDATE \n\n\xef\x81\xae The name of a relation R \n\n\xef\x81\xae The keyword SET \n\n\xef\x81\xae A list of formulas, each of which will assign a value to an \nattribute of R \n\n\xef\x81\xae The keyword WHERE \n\n\xef\x81\xae A condition \n\n\xef\x81\xae The syntax of the update statement: \n\n UPDATE  R  SET \xef\x80\xbcnew-value assignments\xef\x80\xbe WHERE \xef\x80\xbccondition\xef\x80\xbe; \n84 \n\n\n\nUpdate \n\n\xef\x81\xae Database schema: \n\nStudio(name, address, presC#) \n\nExec(name, address, cert#, netWorth) \n\n\xef\x81\xae Update: \n\n     Modify table Exec by attaching the title \xe2\x80\x98Pres. \xe2\x80\x99 in front of  the name \n\nof every movie executive who is also the president of some studio \n\xef\x81\xae In SQL: \n\n UPDATE Exec \n\n SET name = \xe2\x80\x99Pres. \xe2\x80\x99 || name             \xef\x82\xac this line performs the update \n\n WHERE cert# IN (SELECT presC#  \n\n    FROM Studio); \n85 \n\n\n\nDefining Database Schema \n\n\xef\x81\xae SQL includes two types of statements: \n\n\xef\x81\xae DML \n\n\xef\x81\xae DDL  \n\n\xef\x81\xae So far we looked at the DML part to specify or \n\nmodify the relation/database instances. \n\n\xef\x81\xae The DDL part allows us to define or modify the \n\nrelation/database schemas. \n\n    \n\n86 \n\n\n\nDefining Database Schema \n\n\xef\x81\xae To create a table in SQL: \n\n\xef\x81\xae CREATE TABLE name (list of elements);  \n\n\xe2\x80\xa2 Principal elements are attributes and their types,  \n\n    but declarations of key and constraints may also appear \n\n\xef\x81\xae Example: \n\nCREATE TABLE Star ( \n\n        name CHAR(30),  \n\n        address VARCHAR(255),  \n\n        gender CHAR(1), \n\n        birthdate DATE  \n\n); 87 \n\n\n\nDefining Database Schema \n\n\xef\x81\xae To delete a table from the database: \n\n\xef\x81\xae DROP TABLE name; \n\n\xef\x81\xae Example: \n\nDROP TABLE Star; \n\n88 \n\n\n\nData types \n\n\xef\x81\xae INT or INTEGER  \n\n\xef\x81\xae REAL or FLOAT \n\n\xef\x81\xae DECIMAL(n, d)  -- NUMERIC(n, d) \n\xef\x81\xae DECIMAL(6, 2), e.g., 0123.45 \n\n\xef\x81\xae CHAR(n)/BIT(B) fixed length character/bit string \n\xef\x81\xae Unused part is padded with  the "pad character\xe2\x80\x9d, denoted as \xef\x81\x9e  \n\n\xef\x81\xae VARCHAR(n) / BIT VARYING(n) variable-length strings up \nto n characters \n\n\xef\x81\xae Oracle also uses VARCHAR2(n), which is truly varying length; \n\n     Since VARCHAR uses fixed array with end-marker, it is not \nfollowed any longer in Oracle. \n\n89 \n\n\n\nData types (cont\xe2\x80\x99d) \n\xef\x81\xae SQL2 Syntax for: \n\n-- Time: \'hh:mm:ss[.ss...]\' \n\n-- Date:  \xe2\x80\x99yyyy-mm-dd\xe2\x80\x99     (m =0 or 1) \n\n\xef\x81\xae Example: \n\nCREATE TABLE Days(d DATE); \n\nINSERT INTO Days VALUES(\xe2\x80\x992012-12-23\xe2\x80\x99); \n\n \n\n\xef\x81\xb6  Note 1: In Oracle, the default format of date is \xe2\x80\x99dd-mon-yy\xe2\x80\x99, e.g., \n\n   INSERT INTO Days VALUES(\xe2\x80\x9922-jan-18\xe2\x80\x99);  \n\n\xef\x81\xb6 Note 2: The Oracle function to_date converts a specified format into default, e.g.,  \n\n   INSERT INTO Days VALUES (to_date(\'2018-01-22\', \'yyyy-mm-dd\')); \n\n90 \n\n\n\nAltering Relation Schemas \n\xef\x81\xae Adding Columns  \n\n\xef\x81\xae Add an attribute to an existing relation R: \n\n    ALTER TABLE  R  ADD \xef\x80\xbccolumn declaration\xef\x80\xbe; \n\n\xef\x81\xae Example: Add attribute phone to table Star \n\n\xef\x81\xae ALTER TABLE Star ADD phone CHAR(16); \n\n\xef\x81\xae Removing Columns  \n\n\xef\x81\xae Remove an attribute from a relation R using DROP:  \n\n\xef\x81\xae ALTER TABLE  R  DROP COLUMN \xef\x80\xbccolumn_name\xef\x80\xbe; \n\n\xef\x81\xae Example: Remove column phone from Star \n\n\xef\x81\xae ALTER TABLE Star DROP COLUMN phone; \n\nNote: Can\xe2\x80\x99t drop a column, if it is the only column 91 \n\n\n\nAttribute Properties \n\n\xef\x81\xae We can assert that the value of an attribute A to be: \n\n\xef\x81\xae NOT NULL \n\n\xe2\x80\xa2 Then every tuple must have a \xe2\x80\x9creal\xe2\x80\x9d value (not null) for this \n\nattribute  \n\n\xef\x81\xae DEFAULT value \n\n\xe2\x80\xa2 Null is the default value for every attribute \n\n\xe2\x80\xa2 However, we can consider/define any value we wish as the \n\ndefault for a column, when we create a table. \n\n92 \n\n\n\nAttribute Properties \nCREATE TABLE Star ( \n\n        name CHAR(30),  \n\n        address VARCHAR(255),  \n\n        gender CHAR(1) DEFAULT \xe2\x80\x99?\xe2\x80\x99, \n\n        birthdate DATE NOT NULL); \n\n\xef\x81\xae Example: Add an attribute with a default value: \n\n\xef\x81\xae ALTER TABLE Star ADD phone CHAR(16) DEFAULT \xe2\x80\x99unlisted\xe2\x80\x99; \n\xef\x81\xae INSERT INTO Star(name, birthdate) VALUES (\xe2\x80\x99Sally\xe2\x80\x99 ,\xe2\x80\x990000-00-00\xe2\x80\x99) \n\nname address   gender     birthdate   phone   \n\nSally   NULL   ?     0000-00-00   unlisted \n\n\xef\x81\xae INSERT INTO Star(name, phone) VALUES (\xe2\x80\x99Sally\xe2\x80\x99, \xe2\x80\x99333-2255\xe2\x80\x99); \n\n\xef\x81\xae this insertion op. fails since the value for birthdate is not given,  \n\nsince Null was disallowed by the user. \n93 \n\n\n\nAttribute Properties \nTo add default value after an attribute is defined: \n\n\xef\x81\xae ALTER TABLE Star ALTER phone SET DEFAULT \xe2\x80\x98no-phone\xe2\x80\x99; \n\xef\x81\xae In Oracle:  \n\n     ALTER TABLE Star MODIFY phone DEFAULT \xe2\x80\x98no-phone\xe2\x80\x99; \n \n\n94 \n\n\n'